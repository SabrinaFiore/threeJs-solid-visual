{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component, ViewChild } from '@angular/core';\nimport * as THREE from 'three';\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport fragmentShader from '../../../assets/shaders/fragment-shader.glsl';\nimport vertexShader from '../../../assets/shaders/vertex-shader.glsl';\nimport { SphereGeometry, Vector3 } from 'three';\nlet SphereComponent = class SphereComponent {\n  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {\n    this.texture = new THREE.TextureLoader().load('../assets/images/flower01.jpg');\n    this.time = 0;\n    this.scene = new THREE.Scene(); // this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    // this.camera.position.z = 3;\n\n    this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);\n    this.camera.position.z = 50;\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true // alpha: true\n\n    });\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n    this.resize();\n    this.setupResize();\n    this.addObjects();\n    this.addSecondObject();\n    this.render(); // super();\n\n    this.type = 'SphereGeometry';\n    this.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vector3();\n    const normal = new Vector3(); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments; // special case for the poles\n\n      let uOffset = 0;\n\n      if (iy == 0 && thetaStart == 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy == heightSegments && thetaEnd == Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments; // vertex\n\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normal.copy(vertex).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n      }\n\n      grid.push(verticesRow);\n    } // indices\n\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n      }\n    } // build geometry\n    // this.setIndex( indices );\n    // this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    // this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    // this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n  }\n\n  ngOnInit() {\n    this.onPageLoad();\n  }\n\n  ngAfterViewInit() {\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.dom.nativeElement.appendChild(this.renderer.domElement);\n  }\n\n  onPageLoad() {// this.dom.nativeElement.getElementById('dom');\n    // this.dom = options.dom;\n  }\n\n  setupResize() {\n    window.addEventListener('resize', this.resize.bind(this));\n  }\n\n  resize() {\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.camera.aspect = window.innerWidth / window.innerHeight;\n    this.camera.updateProjectionMatrix();\n  }\n\n  addObjects() {\n    /** Flat cube */\n    // this.geometry = new THREE.PlaneBufferGeometry( 100, 100, 10, 10 );\n\n    /** Flat Sphere */\n    this.geometry = new THREE.SphereBufferGeometry(0.4, 40, 40);\n    this.material = new THREE.MeshNormalMaterial();\n    this.material = new THREE.ShaderMaterial({\n      uniforms: {\n        time: {\n          value: 0\n        } // imageTexture: {value: this.texture},\n\n      },\n      side: THREE.DoubleSide,\n      fragmentShader: fragmentShader,\n      vertexShader: vertexShader,\n      wireframe: true\n    });\n    this.mesh = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.mesh);\n    console.log(this.mesh);\n  }\n\n  addSecondObject() {\n    const geometry = new THREE.SphereGeometry(15, 32, 16); // create a simple square shape. We duplicate the top left and bottom right\n    // vertices because each vertex needs to appear once per triangle.\n\n    const vertices = new Float32Array([-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0]); // itemSize = 3 because there are 3 values (components) per vertex\n\n    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n    const material = new THREE.MeshBasicMaterial({\n      color: 0xffff00\n    });\n    const mesh = new THREE.Mesh(geometry, material); // this.setPositionSecondObj(this.mesh);\n\n    this.scene.add(mesh);\n  }\n\n  setPositionSecondObj(mesh) {\n    console.log(mesh);\n    mesh.position.z += 0.05;\n    mesh.position.y += 1.075;\n    mesh.position.x += 0.05;\n  }\n\n  render() {\n    this.time += 0.5;\n    this.mesh.rotation.x = this.time / 1000;\n    this.mesh.rotation.y = this.time / 1000;\n    this.material.uniforms.time.value = this.time;\n    this.renderer.render(this.scene, this.camera);\n    window.requestAnimationFrame(this.render.bind(this));\n  }\n\n  static fromJSON(data) {\n    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n  }\n\n};\n\n__decorate([ViewChild('dom', {\n  static: true\n})], SphereComponent.prototype, \"dom\", void 0);\n\nSphereComponent = __decorate([Component({\n  selector: 'app-sphere',\n  templateUrl: './sphere.component.html',\n  styleUrls: ['./sphere.component.scss']\n})], SphereComponent);\nexport { SphereComponent };","map":null,"metadata":{},"sourceType":"module"}