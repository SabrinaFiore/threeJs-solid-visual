{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Component, ChangeDetectionStrategy, Self, Inject, HostBinding, Input, Output, ViewChild, Directive, NgModule, InjectionToken, Optional, ChangeDetectorRef, SkipSelf, ContentChildren, ContentChild, Pipe, ViewContainerRef, TemplateRef } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { isObservable, combineLatest, Subject, forkJoin, of, defer, throwError, shareReplay, fromEvent, asapScheduler, ReplaySubject, BehaviorSubject } from 'rxjs';\nimport { tap, withLatestFrom, skip, filter, mapTo, catchError, map, takeUntil, observeOn, take } from 'rxjs/operators';\nimport * as THREE from 'three';\nimport { Vector3, Vector2, Clock, WebGLRenderer, PCFSoftShadowMap, ACESFilmicToneMapping, sRGBEncoding, Scene, Camera, OrthographicCamera, PerspectiveCamera, Raycaster, Object3D, Color, Material, BufferGeometry, SpriteMaterial } from 'three';\nimport { __rest } from 'tslib';\nimport { ComponentStore } from '@ngrx/component-store';\n/**\n * Generate a random Id or an Event's uuid\n *\n * @param {ThreeIntersection} event\n *\n * @internal\n * @private\n */\n\nconst _c0 = [\"rendererCanvas\"];\n\nfunction makeId(event) {\n  if (event) {\n    return (event.eventObject || event.object).uuid + '/' + event.index;\n  }\n\n  return id();\n}\n\nconst cache = {};\n/**\n * Generates a short id.\n *\n * Description:\n *  A 5-character alphanumeric sequence (364 = 1.6 million)\n *  This should only be used for JavaScript specific models.\n *  http://stackoverflow.com/questions/6248666/how-to-generate-short-uid-like-ax4j9z-in-js\n *\n *  Example: `aebgf`\n */\n\nfunction id() {\n  let newId = ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);\n  newId = `a${newId}`; // ensure not already used\n\n  if (!cache[newId]) {\n    cache[newId] = true;\n    return newId;\n  }\n\n  return id();\n}\n/**\n * From r3f https://github.com/pmndrs/react-three-fiber/blob/master/packages/fiber/src/core/events.ts\n */\n\n\nfunction createEvents(canvasStateGetter, eventsStateGetter, instancesStateGetter) {\n  const temp = new Vector3();\n  /** Sets up defaultRaycaster */\n\n  function prepareRay(event) {\n    var _a, _b;\n\n    const {\n      raycaster,\n      mouse,\n      camera,\n      clock,\n      renderer,\n      scene,\n      internal: {\n        size,\n        viewport\n      }\n    } = canvasStateGetter();\n    const delta = clock.getDelta();\n\n    if (raycaster && camera && renderer && scene) {\n      const {\n        offsetX,\n        offsetY\n      } = (_b = (_a = raycaster.computeOffsets) === null || _a === void 0 ? void 0 : _a.call(raycaster, event, {\n        camera,\n        clock,\n        size,\n        viewport,\n        renderer,\n        scene,\n        delta,\n        mouse\n      })) !== null && _b !== void 0 ? _b : event;\n      const {\n        width,\n        height\n      } = size;\n      mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);\n      raycaster.setFromCamera(mouse, camera);\n    }\n  }\n  /** Calculates delta */\n\n\n  function calculateDistance(event) {\n    const {\n      internal: {\n        initialClick\n      }\n    } = eventsStateGetter();\n    const dx = event.offsetX - initialClick[0];\n    const dy = event.offsetY - initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n\n\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['move', 'over', 'enter', 'out', 'leave'].some(name => {\n      var _a, _b;\n\n      return (_b = (_a = obj.__ngt) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b['pointer' + name];\n    }));\n  }\n\n  function intersect(filter) {\n    var _a;\n\n    const {\n      raycaster\n    } = canvasStateGetter();\n    const {\n      objects\n    } = instancesStateGetter(); // Skip event handling when noEvents is set\n\n    if (!raycaster || raycaster && !raycaster.enabled) return [];\n    const seen = new Set();\n    const intersections = []; // Allow callers to eliminate event objects\n\n    const eventsObjects = filter ? filter(Object.values(objects)) : Object.values(objects); // Intersect known handler objects and filter against duplicates\n\n    const intersects = raycaster.intersectObjects(eventsObjects, true).filter(item => {\n      const id = makeId(item);\n      if (seen.has(id)) return false;\n      seen.add(id);\n      return true;\n    }); // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order\n    // if (raycaster.filter) intersects = raycaster.filter(intersects, state);\n\n    for (const intersect of intersects) {\n      let eventObject = intersect.object; // Bubble event up\n\n      while (eventObject) {\n        const handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;\n        if (handlers) intersections.push(Object.assign(Object.assign({}, intersect), {\n          eventObject\n        }));\n        eventObject = eventObject.parent;\n      }\n    }\n\n    return intersections;\n  }\n  /**  Creates filtered intersects and returns an array of positive hits */\n\n\n  function patchIntersects(intersections, event) {\n    const {\n      internal: {\n        capturedMap\n      }\n    } = eventsStateGetter(); // If the interaction is captured take that into account, the captured event has to be part of the intersects\n\n    if ('pointerId' in event && capturedMap.has(event.pointerId)) {\n      intersections.push(...capturedMap.get(event.pointerId).values());\n    }\n\n    return intersections;\n  }\n  /**  Handles intersections by forwarding them to handlers */\n\n\n  function handleIntersects(intersections, event, callback) {\n    const {\n      raycaster,\n      mouse,\n      camera\n    } = canvasStateGetter();\n    const {\n      internal: eventsInternal\n    } = eventsStateGetter(); // If anything has been found, forward it to the event listeners\n\n    if (intersections.length && camera) {\n      const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);\n      const delta = event.type === 'click' ? calculateDistance(event) : 0;\n\n      const releasePointerCapture = id => event.target.releasePointerCapture(id);\n\n      const localState = {\n        stopped: false\n      };\n\n      for (const hit of intersections) {\n        const hasPointerCapture = id => {\n          var _a, _b;\n\n          return (_b = (_a = eventsInternal.capturedMap.get(id)) === null || _a === void 0 ? void 0 : _a.has(hit.eventObject)) !== null && _b !== void 0 ? _b : false;\n        };\n\n        const setPointerCapture = id => {\n          if (eventsInternal.capturedMap.has(id)) {\n            // if the pointerId was previously captured, we add the hit to the\n            // event capturedMap.\n            eventsInternal.capturedMap.get(id).set(hit.eventObject, hit);\n          } else {\n            // if the pointerId was not previously captured, we create a map\n            // containing the hitObject, and the hit. hitObject is used for\n            // faster access.\n            eventsInternal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));\n          } // Call the original event now\n\n\n          event.target.setPointerCapture(id);\n        }; // Add native event props\n\n\n        const extractEventProps = {};\n\n        for (const prop in Object.getPrototypeOf(event)) {\n          // noinspection JSUnfilteredForInLoop\n          const property = event[prop]; // Only copy over atomics, leave functions alone as these should be\n          // called as event.nativeEvent.fn()\n\n          if (typeof property !== 'function') {\n            // noinspection JSUnfilteredForInLoop\n            extractEventProps[prop] = property;\n          }\n        }\n\n        const raycastEvent = Object.assign(Object.assign(Object.assign({}, hit), extractEventProps), {\n          spaceX: mouse.x,\n          spaceY: mouse.y,\n          intersections,\n          stopped: localState.stopped,\n          delta,\n          unprojectedPoint,\n          ray: raycaster ? raycaster.ray : null,\n          camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation: () => {\n            // https://github.com/pmndrs/react-three-fiber/issues/596\n            // Events are not allowed to stop propagation if the pointer has been captured\n            const capturesForPointer = 'pointerId' in event && eventsInternal.capturedMap.get(event.pointerId); // We only authorize stopPropagation...\n\n            if ( // ...if this pointer hasn't been captured\n            !capturesForPointer || // ... or if the hit object is capturing the pointer\n            capturesForPointer.has(hit.eventObject)) {\n              raycastEvent.stopped = localState.stopped = true; // Propagation is stopped, remove all other hover records\n              // An event handler is only allowed to flush other handlers if it is hovered itself\n\n              if (eventsInternal.hovered.size && Array.from(eventsInternal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                // Objects cannot flush out higher up objects that have already caught the event\n                const higher = intersections.slice(0, intersections.indexOf(hit));\n                cancelPointer([...higher, hit]);\n              }\n            }\n          },\n          target: Object.assign(Object.assign({}, event.target), {\n            setPointerCapture,\n            releasePointerCapture,\n            hasPointerCapture\n          }),\n          currentTarget: Object.assign(Object.assign({}, event.currentTarget), {\n            setPointerCapture,\n            releasePointerCapture,\n            hasPointerCapture\n          }),\n          sourceEvent: event,\n          nativeEvent: event\n        }); // Call subscribers\n\n        callback(raycastEvent); // Event bubbling may be interrupted by stopPropagation\n\n        if (localState.stopped) break;\n      }\n    }\n\n    return intersections;\n  }\n\n  function cancelPointer(hits) {\n    const {\n      internal\n    } = eventsStateGetter();\n    Array.from(internal.hovered.values()).forEach(hoveredObj => {\n      var _a, _b, _c; // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n\n\n      if (!hits.length || !hits.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index)) {\n        const eventObject = hoveredObj.eventObject;\n        const handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;\n        internal.hovered.delete(makeId(hoveredObj));\n\n        if (handlers) {\n          // Clear out intersects, they are outdated by now\n          const data = Object.assign(Object.assign({}, hoveredObj), {\n            intersections: hits || []\n          });\n          (_b = handlers.pointerout) === null || _b === void 0 ? void 0 : _b.call(handlers, data);\n          (_c = handlers.pointerleave) === null || _c === void 0 ? void 0 : _c.call(handlers, data);\n        }\n      }\n    });\n  }\n\n  const handlePointer = name => {\n    // Deal with cancellation\n    switch (name) {\n      case 'pointerleave':\n      case 'pointercancel':\n        return () => cancelPointer([]);\n\n      case 'lostpointercapture':\n        return event => {\n          if ('pointerId' in event) {\n            // this will be a problem if one target releases the pointerId\n            // and another one is still keeping it, as the line below\n            // indifferently deletes all capturing references.\n            const {\n              internal: {\n                capturedMap\n              }\n            } = eventsStateGetter();\n            capturedMap.delete(event.pointerId);\n          }\n        };\n    } // Any other pointer goes here ...\n\n\n    return event => {\n      const {\n        internal\n      } = eventsStateGetter();\n      const {\n        objects\n      } = instancesStateGetter();\n      prepareRay(event); // Get fresh intersects\n\n      const isPointerMove = name === 'pointermove';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = patchIntersects(intersect(filter), event); // Take care of unhover\n\n      if (isPointerMove) cancelPointer(hits);\n      handleIntersects(hits, event, data => {\n        var _a, _b, _c, _d;\n\n        const eventObject = data.eventObject;\n        const handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers; // Check presence of handlers\n\n        if (!handlers) return;\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.pointerover || handlers.pointerenter || handlers.pointerout || handlers.pointerleave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              (_b = handlers.pointerover) === null || _b === void 0 ? void 0 : _b.call(handlers, data);\n              (_c = handlers.pointerenter) === null || _c === void 0 ? void 0 : _c.call(handlers, data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          } // Call mouse move\n\n\n          (_d = handlers.pointermove) === null || _d === void 0 ? void 0 : _d.call(handlers, data);\n        } else {\n          // All other events ...\n          const handler = handlers === null || handlers === void 0 ? void 0 : handlers[name];\n\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (name !== 'click' && name !== 'contextmenu' && name !== 'dblclick' || internal.initialHits.includes(eventObject)) {\n              handler(data);\n              pointerMissed(event, Object.values(objects).filter(object => object !== eventObject));\n            }\n          }\n        }\n      }); // Save initial coordinates on pointer-down\n\n      if (name === 'pointerdown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      } // If a click yields no results, pass it back to the user as a miss\n\n\n      if ((name === 'click' || name === 'contextmenu' || name === 'dblclick') && !hits.length) {\n        if (calculateDistance(event) <= 2) {\n          pointerMissed(event, Object.values(objects)); // if (onPointerMissed) onPointerMissed();\n        }\n      }\n    };\n  };\n\n  function pointerMissed(event, objects) {\n    objects.forEach(object => {\n      var _a, _b, _c;\n\n      return (_c = (_b = (_a = object.__ngt) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.pointermissed) === null || _c === void 0 ? void 0 : _c.call(_b, event);\n    });\n  }\n\n  return {\n    handlePointer\n  };\n}\n\nfunction applyDottedPathProps(instance, key, propAtKey, isRoot = true) {\n  const [first, ...paths] = key.split('.');\n  const rootChild = instance[first];\n\n  if (rootChild == null) {\n    return;\n  }\n\n  if (paths.length >= 1) {\n    applyDottedPathProps(rootChild, paths.join('.'), propAtKey, false);\n  } else {\n    instance[first] = propAtKey;\n  }\n\n  if (isRoot) {\n    checkNeedsUpdate(rootChild);\n  }\n}\n\nfunction checkNeedsUpdate(value) {\n  if (typeof value === 'object' && 'needsUpdate' in value) {\n    value['needsUpdate'] = true;\n  }\n}\n/**\n * Apply props on instances\n *\n * @internal\n * @private\n */\n\n\nfunction applyProps(instance, props) {\n  if (!props || props && !Object.keys(props).length) return;\n\n  if ('__ngt' in props) {\n    instance['__ngt'] = props['__ngt'];\n  }\n\n  const unknownInstance = instance;\n\n  if (unknownInstance['set'] != null && typeof unknownInstance['set'] === 'function') {\n    unknownInstance['set'](props);\n  }\n\n  for (const [key, propAtKey] of Object.entries(props)) {\n    if (key.split('.').length > 1) {\n      applyDottedPathProps(instance, key, propAtKey);\n    } else {\n      const threeInstancePropAtKey = unknownInstance[key];\n\n      if (threeInstancePropAtKey == null) {\n        unknownInstance[key] = propAtKey;\n      } else {\n        if (threeInstancePropAtKey['set'] != null && typeof threeInstancePropAtKey['set'] === 'function') {\n          if (Array.isArray(propAtKey)) {\n            if (threeInstancePropAtKey['fromArray'] != null && typeof threeInstancePropAtKey['fromArray'] === 'function') {\n              threeInstancePropAtKey['fromArray'](propAtKey);\n            } else {\n              threeInstancePropAtKey['set'](...propAtKey);\n            }\n          } else {\n            threeInstancePropAtKey['set'](propAtKey);\n          }\n        } else {\n          unknownInstance[key] = propAtKey;\n        }\n      }\n\n      checkNeedsUpdate(propAtKey);\n    }\n  }\n}\n\nclass ImperativeComponentStore extends ComponentStore {\n  getImperativeState() {\n    return this.get();\n  }\n\n}\n\nlet AnimationStore = /*#__PURE__*/(() => {\n  class AnimationStore extends ImperativeComponentStore {\n    constructor() {\n      super({\n        animations: {},\n        objectSubscriptions: [],\n        animationCallbacks: [],\n        hasPriority: false\n      });\n      this.animationsChangedEffect = this.effect(animations$ => animations$.pipe(tap(animations => {\n        const animationCallbacks = Object.values(animations);\n        const hasPriority = animationCallbacks.some(({\n          priority\n        }) => !!priority);\n        this.patchState({\n          animationCallbacks,\n          hasPriority\n        });\n      })));\n      this.unregisterAnimationEffect = this.effect(uuid$ => uuid$.pipe(withLatestFrom(this.state$), tap(([uuid, {\n        animations,\n        objectSubscriptions\n      }]) => {\n        const subscription = objectSubscriptions.find(([objectUuid]) => objectUuid === uuid);\n\n        if (subscription) {\n          subscription[1].unsubscribe();\n        }\n\n        const _a = animations,\n              _b = uuid,\n              _ = _a[_b],\n              updatedAnimations = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n        this.patchState({\n          animations: updatedAnimations,\n          objectSubscriptions: objectSubscriptions.filter(([objectUuid]) => objectUuid !== uuid)\n        });\n      })));\n      this.clearEffect = this.effect(trigger$ => trigger$.pipe(tap(() => {\n        this.patchState(state => {\n          state.objectSubscriptions.forEach(([, subscription]) => subscription.unsubscribe());\n          return {\n            animations: {},\n            objectSubscriptions: []\n          };\n        });\n      })));\n      this.animationsChangedEffect(this.select(s => s.animations).pipe(skip(1)));\n    }\n\n    registerAnimation(objOrObsOrCallback, callbackOrPriority, priority = 0) {\n      if (objOrObsOrCallback === undefined) return;\n\n      if (typeof objOrObsOrCallback === 'function') {\n        const id = makeId();\n        this.patchState(state => Object.assign(Object.assign({}, state), {\n          animations: Object.assign(Object.assign({}, state.animations), {\n            [id]: {\n              obj: null,\n              callback: objOrObsOrCallback,\n              priority: callbackOrPriority || 0\n            }\n          })\n        }));\n        return () => {\n          this.unregisterAnimationEffect(id);\n        };\n      }\n\n      if (isObservable(objOrObsOrCallback)) {\n        let id = '';\n        const subscription = objOrObsOrCallback.pipe(filter(obj => !!obj)).subscribe(obj => {\n          this.patchState(state => {\n            var _a;\n\n            const objectSubscriptions = state.objectSubscriptions;\n\n            if ((_a = objectSubscriptions[objectSubscriptions.length - 1]) === null || _a === void 0 ? void 0 : _a[0]) {\n              objectSubscriptions[objectSubscriptions.length - 1][0] = obj.uuid;\n            }\n\n            id = obj.uuid;\n            return {\n              animations: Object.assign(Object.assign({}, state.animations), {\n                [id]: {\n                  obj,\n                  callback: callbackOrPriority,\n                  priority\n                }\n              }),\n              objectSubscriptions\n            };\n          });\n        });\n        this.patchState(state => ({\n          objectSubscriptions: [...state.objectSubscriptions, [null, subscription]]\n        }));\n        return () => {\n          this.unregisterAnimationEffect(id);\n        };\n      }\n\n      const uuid = objOrObsOrCallback.uuid;\n      this.patchState(state => ({\n        animations: Object.assign(Object.assign({}, state.animations), {\n          [uuid]: {\n            obj: objOrObsOrCallback,\n            callback: callbackOrPriority,\n            priority\n          }\n        })\n      }));\n      return () => {\n        this.unregisterAnimationEffect(uuid);\n      };\n    }\n\n    ngOnDestroy() {\n      this.clearEffect();\n      super.ngOnDestroy();\n    }\n\n  }\n\n  AnimationStore.ɵfac = function AnimationStore_Factory(t) {\n    return new (t || AnimationStore)();\n  };\n\n  AnimationStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnimationStore,\n    factory: AnimationStore.ɵfac\n  });\n  return AnimationStore;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst position = new Vector3();\nconst defaultTarget = new Vector3();\n\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\n\nlet CanvasStore = /*#__PURE__*/(() => {\n  class CanvasStore extends ImperativeComponentStore {\n    constructor() {\n      super({\n        isOrthographic: false,\n        isLinear: false,\n        shadows: false,\n        mouse: new Vector2(),\n        clock: new Clock(),\n        internal: {\n          active: false,\n          size: {\n            width: 0,\n            height: 0\n          },\n          dpr: 1,\n          viewport: {\n            initialDpr: 1,\n            dpr: 1,\n            width: 0,\n            height: 0,\n            aspect: 0,\n            distance: 0,\n            factor: 0,\n            getCurrentViewport: (camera = this.getImperativeState().camera, target = defaultTarget, size = this.getImperativeState().internal.size) => {\n              const {\n                width,\n                height\n              } = size;\n              const aspect = width / height;\n              const distance = camera.getWorldPosition(position).distanceTo(target);\n\n              if (isOrthographicCamera(camera)) {\n                return {\n                  width: width / camera.zoom,\n                  height: height / camera.zoom,\n                  factor: 1,\n                  distance,\n                  aspect\n                };\n              }\n\n              const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n\n              const h = 2 * Math.tan(fov / 2) * distance; // visible height\n\n              const w = h * (width / height);\n              return {\n                width: w,\n                height: h,\n                factor: width / w,\n                distance,\n                aspect\n              };\n            }\n          }\n        }\n      });\n      this.renderer$ = this.select(s => s.renderer);\n      this.camera$ = this.select(s => s.camera);\n      this.scene$ = this.select(s => s.scene);\n      this.raycaster$ = this.select(s => s.raycaster);\n      this.isOrthographic$ = this.select(s => s.isOrthographic);\n      this.isLinear$ = this.select(s => s.isLinear);\n      this.shadows$ = this.select(s => s.shadows);\n      this.active$ = this.select(s => s.internal.active);\n      this.canvasInternal$ = this.select(s => s.internal);\n      this.setIsOrthographic = this.updater((state, isOrthographic) => Object.assign(Object.assign({}, state), {\n        isOrthographic\n      }));\n      this.setIsLinear = this.updater((state, isLinear) => Object.assign(Object.assign({}, state), {\n        isLinear\n      }));\n      this.setShadows = this.updater((state, shadows) => Object.assign(Object.assign({}, state), {\n        shadows\n      }));\n      this.setSize = this.updater((state, size) => Object.assign(Object.assign({}, state), {\n        internal: Object.assign(Object.assign({}, state.internal), {\n          size\n        })\n      }));\n      this.setDpr = this.updater((state, dpr) => Object.assign(Object.assign({}, state), {\n        internal: Object.assign(Object.assign({}, state.internal), {\n          dpr\n        })\n      }));\n      this.setViewport = this.updater(state => Object.assign(Object.assign({}, state), {\n        internal: Object.assign(Object.assign({}, state.internal), {\n          viewport: Object.assign(Object.assign(Object.assign({}, state.internal.viewport), state.internal.viewport.getCurrentViewport(state.camera, defaultTarget, state.internal.size)), {\n            dpr: state.internal.dpr\n          })\n        })\n      }));\n      this.setActive = this.updater((state, active) => Object.assign(Object.assign({}, state), {\n        internal: Object.assign(Object.assign({}, state.internal), {\n          active\n        })\n      }));\n      this.initRendererEffect = this.effect(canvas$ => {\n        return canvas$.pipe(withLatestFrom(this.canvasInternal$, this.isLinear$, this.shadows$), tap(([canvas, {\n          size,\n          dpr\n        }, isLinear, shadows]) => {\n          const renderer = new WebGLRenderer({\n            canvas,\n            antialias: true,\n            powerPreference: 'high-performance',\n            alpha: true\n          });\n\n          if (shadows) {\n            renderer.shadowMap.enabled = true;\n            if (typeof shadows === 'object') Object.assign(renderer.shadowMap, shadows);else renderer.shadowMap.type = PCFSoftShadowMap;\n          }\n\n          if (!isLinear) {\n            renderer.toneMapping = ACESFilmicToneMapping;\n            renderer.outputEncoding = sRGBEncoding;\n          }\n\n          renderer.setClearAlpha(0);\n          renderer.setPixelRatio(dpr);\n          renderer.setSize(size.width, size.height);\n          this.patchState({\n            renderer\n          });\n        }));\n      });\n      this.initSceneEffect = this.effect(sceneOptions$ => sceneOptions$.pipe(tap(sceneOptions => {\n        const scene = new Scene();\n        applyProps(scene, sceneOptions);\n        this.patchState({\n          scene\n        });\n      })));\n      this.initCameraEffect = this.effect(cameraOptions$ => cameraOptions$.pipe(withLatestFrom(this.isOrthographic$, this.canvasInternal$), tap(([cameraOptions, isOrthographic, {\n        size\n      }]) => {\n        var _a;\n\n        const isCamera = cameraOptions instanceof Camera;\n        let camera;\n\n        if (isCamera) {\n          camera = cameraOptions;\n        } else {\n          if (isOrthographic) {\n            camera = new OrthographicCamera(0, 0, 0, 0, 0.1, 1000);\n            camera.zoom = 100;\n          } else {\n            camera = new PerspectiveCamera(75, (_a = size.width / size.height) !== null && _a !== void 0 ? _a : 0, 0.1, 1000);\n          }\n\n          camera.position.z = 5;\n          applyProps(camera, cameraOptions); // Update projection matrix after applying props\n\n          camera.updateProjectionMatrix();\n        } // look at center by default\n\n\n        camera.lookAt(0, 0, 0);\n        this.patchState({\n          camera\n        });\n        this.setViewport();\n      })));\n      this.initRaycasterEffect = this.effect(raycasterOptions$ => raycasterOptions$.pipe(tap(raycasterOptions => {\n        const raycaster = new Raycaster();\n        raycaster.enabled = true;\n        applyProps(raycaster, raycasterOptions);\n        this.patchState({\n          raycaster\n        });\n      })));\n      this.windowResizeEffect = this.effect(params$ => params$.pipe(withLatestFrom(this.renderer$, this.camera$), tap(([{\n        dpr,\n        size\n      }, renderer, camera]) => {\n        if (camera.type === 'PerspectiveCamera') {\n          camera.aspect = size.width / size.height;\n        } else {\n          camera.left = size.width / -2;\n          camera.right = size.width / 2;\n          camera.top = size.height / 2;\n          camera.bottom = size.height / -2;\n        }\n\n        camera.updateProjectionMatrix();\n        camera.updateMatrixWorld();\n        renderer.setPixelRatio(dpr);\n        renderer.setSize(size.width, size.height);\n        this.setSize(size);\n        this.setDpr(dpr);\n        this.setViewport();\n      })));\n      this.setActive(combineLatest([this.renderer$, this.camera$, this.scene$, this.raycaster$]).pipe(filter(coreObjects => coreObjects.every(Boolean)), mapTo(true)));\n    }\n\n    ngOnDestroy() {\n      const {\n        renderer\n      } = this.getImperativeState();\n\n      if (renderer) {\n        renderer.renderLists.dispose();\n        renderer.forceContextLoss();\n      }\n\n      super.ngOnDestroy();\n    }\n\n  }\n\n  CanvasStore.ɵfac = function CanvasStore_Factory(t) {\n    return new (t || CanvasStore)();\n  };\n\n  CanvasStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CanvasStore,\n    factory: CanvasStore.ɵfac\n  });\n  return CanvasStore;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet InstancesStore = /*#__PURE__*/(() => {\n  class InstancesStore extends ImperativeComponentStore {\n    constructor() {\n      super({\n        materials: {},\n        bufferGeometries: {},\n        objects: {}\n      });\n      this.saveMaterial = this.updater((state, {\n        material,\n        id = material.uuid\n      }) => Object.assign(Object.assign({}, state), {\n        materials: Object.assign(Object.assign({}, state.materials), {\n          [id]: material\n        })\n      }));\n      this.removeMaterial = this.updater((state, id) => {\n        const _a = state.materials,\n              _b = id,\n              _ = _a[_b],\n              materials = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n        return Object.assign(Object.assign({}, state), {\n          materials\n        });\n      });\n      this.saveBufferGeometry = this.updater((state, {\n        bufferGeometry,\n        id = bufferGeometry.uuid\n      }) => Object.assign(Object.assign({}, state), {\n        bufferGeometries: Object.assign(Object.assign({}, state.bufferGeometries), {\n          [id]: bufferGeometry\n        })\n      }));\n      this.removeBufferGeometry = this.updater((state, id) => {\n        const _a = state.bufferGeometries,\n              _b = id,\n              _ = _a[_b],\n              bufferGeometries = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n        return Object.assign(Object.assign({}, state), {\n          bufferGeometries\n        });\n      });\n      this.saveObject = this.updater((state, obj) => Object.assign(Object.assign({}, state), {\n        objects: Object.assign(Object.assign({}, state.objects), {\n          [obj.uuid]: obj\n        })\n      }));\n      this.removeObject = this.updater((state, id) => {\n        const _a = state.objects,\n              _b = id,\n              _ = _a[_b],\n              objects = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n        return Object.assign(Object.assign({}, state), {\n          objects\n        });\n      });\n    }\n\n  }\n\n  InstancesStore.ɵfac = function InstancesStore_Factory(t) {\n    return new (t || InstancesStore)();\n  };\n\n  InstancesStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InstancesStore,\n    factory: InstancesStore.ɵfac\n  });\n  return InstancesStore;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst events = {\n  click: false,\n  contextmenu: false,\n  dblclick: false,\n  wheel: true,\n  pointerdown: true,\n  pointerup: true,\n  pointerleave: true,\n  pointermove: true,\n  pointercancel: true,\n  lostpointercapture: true\n};\nlet EventsStore = /*#__PURE__*/(() => {\n  class EventsStore extends ImperativeComponentStore {\n    constructor(canvasStore, instancesStore) {\n      super({\n        connected: false,\n        internal: {\n          interaction: [],\n          hovered: new Map(),\n          capturedMap: new Map(),\n          initialClick: [0, 0],\n          initialHits: []\n        }\n      });\n      this.canvasStore = canvasStore;\n      this.instancesStore = instancesStore;\n      this.initHandlersEffect = this.effect(trigger$ => trigger$.pipe(tap(() => {\n        const {\n          handlePointer\n        } = createEvents(() => this.canvasStore.getImperativeState(), () => this.getImperativeState(), () => this.instancesStore.getImperativeState());\n        this.patchState({\n          handlers: Object.keys(events).reduce((handlers, supportedEventName) => {\n            handlers[supportedEventName] = handlePointer(supportedEventName);\n            return handlers;\n          }, {})\n        });\n      })));\n      this.connectEffect = this.effect(target$ => target$.pipe(tap(target => {\n        this.disconnectEffect();\n        const {\n          handlers\n        } = this.getImperativeState();\n        this.patchState({\n          connected: target\n        });\n        Object.entries(handlers !== null && handlers !== void 0 ? handlers : []).forEach(([name, event]) => {\n          const passive = events[name];\n          target.addEventListener(name, event, {\n            passive\n          });\n        });\n      })));\n      this.disconnectEffect = this.effect(trigger$ => trigger$.pipe(tap(() => {\n        const {\n          handlers,\n          connected\n        } = this.getImperativeState();\n\n        if (connected) {\n          Object.entries(handlers !== null && handlers !== void 0 ? handlers : []).forEach(([name, event]) => {\n            if (connected instanceof HTMLElement) {\n              connected.removeEventListener(name, event);\n            }\n          });\n          this.patchState({\n            connected: false\n          });\n        }\n      })));\n      this.initHandlersEffect();\n    }\n\n    ngOnDestroy() {\n      this.disconnectEffect();\n      super.ngOnDestroy();\n    }\n\n  }\n\n  EventsStore.ɵfac = function EventsStore_Factory(t) {\n    return new (t || EventsStore)(i0.ɵɵinject(CanvasStore), i0.ɵɵinject(InstancesStore));\n  };\n\n  EventsStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: EventsStore,\n    factory: EventsStore.ɵfac\n  });\n  return EventsStore;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LoopService = /*#__PURE__*/(() => {\n  class LoopService {\n    // TODO: rethink limit 60fps\n    // private readonly interval = 1 / 60; // 60fps;\n    // private internalDelta = 0;\n    constructor(canvasStore, animationStore) {\n      this.canvasStore = canvasStore;\n      this.animationStore = animationStore;\n      this.loopClock = new Clock();\n    }\n\n    start() {\n      const {\n        renderer\n      } = this.canvasStore.getImperativeState();\n\n      if (renderer) {\n        renderer.setAnimationLoop(() => {\n          this.tick(this.loopClock.getDelta());\n        });\n      }\n    }\n\n    stop() {\n      const {\n        renderer\n      } = this.canvasStore.getImperativeState();\n\n      if (renderer) {\n        renderer.setAnimationLoop(null);\n      }\n    }\n\n    tick(delta) {\n      // this.internalDelta += delta;\n      //\n      // if (this.internalDelta >= this.interval) {\n      //   const {\n      //     renderer,\n      //     scene,\n      //     camera,\n      //     internal: { size, viewport },\n      //     clock,\n      //     mouse,\n      //   } = this.canvasStore.getImperativeState();\n      //   const { animationCallbacks, hasPriority } =\n      //     this.animationStore.getImperativeState();\n      //\n      //   if (renderer && scene && camera) {\n      //     if (hasPriority) {\n      //       animationCallbacks.sort(\n      //         ({ priority: a = 0 }, { priority: b = 0 }) => a - b\n      //       );\n      //     } else {\n      //       renderer.render(scene, camera);\n      //     }\n      //\n      //     const renderState = {\n      //       clock,\n      //       camera,\n      //       scene,\n      //       renderer,\n      //       mouse,\n      //       size,\n      //       viewport,\n      //       delta,\n      //     };\n      //     for (const animationCallback of animationCallbacks) {\n      //       if (animationCallback.obj) {\n      //         animationCallback.callback(animationCallback.obj, renderState);\n      //       } else {\n      //         animationCallback.callback(renderState);\n      //       }\n      //     }\n      //   }\n      //\n      //   this.internalDelta = this.internalDelta % this.interval;\n      // }\n      const {\n        renderer,\n        scene,\n        camera,\n        internal: {\n          size,\n          viewport\n        },\n        clock,\n        mouse\n      } = this.canvasStore.getImperativeState();\n      const {\n        animationCallbacks,\n        hasPriority\n      } = this.animationStore.getImperativeState();\n\n      if (renderer && scene && camera) {\n        if (hasPriority) {\n          animationCallbacks.sort(({\n            priority: a = 0\n          }, {\n            priority: b = 0\n          }) => a - b);\n        } else {\n          renderer.render(scene, camera);\n        }\n\n        const renderState = {\n          clock,\n          camera,\n          scene,\n          renderer,\n          mouse,\n          size,\n          viewport,\n          delta\n        };\n\n        for (const animationCallback of animationCallbacks) {\n          if (animationCallback.obj) {\n            animationCallback.callback(animationCallback.obj, renderState);\n          } else {\n            animationCallback.callback(renderState);\n          }\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.stop();\n    }\n\n  }\n\n  LoopService.ɵfac = function LoopService_Factory(t) {\n    return new (t || LoopService)(i0.ɵɵinject(CanvasStore), i0.ɵɵinject(AnimationStore));\n  };\n\n  LoopService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LoopService,\n    factory: LoopService.ɵfac\n  });\n  return LoopService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DestroyedService = /*#__PURE__*/(() => {\n  class DestroyedService extends Subject {\n    ngOnDestroy() {\n      this.next();\n      this.complete();\n    }\n\n  }\n\n  DestroyedService.ɵfac = /* @__PURE__ */function () {\n    let ɵDestroyedService_BaseFactory;\n    return function DestroyedService_Factory(t) {\n      return (ɵDestroyedService_BaseFactory || (ɵDestroyedService_BaseFactory = i0.ɵɵgetInheritedFactory(DestroyedService)))(t || DestroyedService);\n    };\n  }();\n\n  DestroyedService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DestroyedService,\n    factory: DestroyedService.ɵfac\n  });\n  return DestroyedService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LoaderService = /*#__PURE__*/(() => {\n  class LoaderService {\n    constructor() {\n      this.cached = new Map();\n    }\n\n    use(loaderConstructor, input, extensions, onProgress) {\n      const keys = Array.isArray(input) ? input : [input];\n      const loader = new loaderConstructor();\n\n      if (extensions) {\n        extensions(loader);\n      }\n\n      const results$ = forkJoin(keys.map(key => {\n        if (this.cached.has(key)) {\n          return of(this.cached.get(key));\n        }\n\n        return defer(() => loader.loadAsync(key, onProgress)).pipe(tap(data => {\n          if (data.scene) {\n            Object.assign(data, this.buildGraph(data.scene));\n          }\n\n          this.cached.set(key, data);\n        }), catchError(err => {\n          console.error(`Error loading ${key}: ${err.message}`);\n          return throwError(err);\n        }));\n      }));\n      return defer(() => Array.isArray(input) ? results$ : results$.pipe(map(results => results[0]))).pipe(shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n\n    ngOnDestroy() {\n      this.cached.clear();\n    }\n\n    buildGraph(object) {\n      const data = {\n        nodes: {},\n        materials: {}\n      };\n\n      if (object) {\n        object.traverse(obj => {\n          if (obj.name) {\n            data.nodes[obj.name] = obj;\n          }\n\n          if (obj.material && !data.materials[obj.material.name]) {\n            data.materials[obj.material.name] = obj.material;\n          }\n        });\n      }\n\n      return data;\n    }\n\n  }\n\n  LoaderService.ɵfac = function LoaderService_Factory(t) {\n    return new (t || LoaderService)();\n  };\n\n  LoaderService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LoaderService,\n    factory: LoaderService.ɵfac,\n    providedIn: 'root'\n  });\n  return LoaderService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CanvasComponent = /*#__PURE__*/(() => {\n  class CanvasComponent {\n    constructor(canvasStore, animationStore, eventsStore, loopService, ngZone, hostElement, document, destroyed) {\n      this.canvasStore = canvasStore;\n      this.animationStore = animationStore;\n      this.eventsStore = eventsStore;\n      this.loopService = loopService;\n      this.ngZone = ngZone;\n      this.hostElement = hostElement;\n      this.document = document;\n      this.destroyed = destroyed;\n      this.hostClass = true;\n      this.raycaster = {};\n      this.created = new EventEmitter();\n    }\n\n    set orthographic(v) {\n      this.canvasStore.setIsOrthographic(v);\n    }\n\n    set linear(v) {\n      this.canvasStore.setIsLinear(v);\n    }\n\n    set shadows(v) {\n      this.canvasStore.setShadows(v);\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        var _a;\n\n        this.canvasStore.setSize({\n          width: this.hostElement.nativeElement.clientWidth,\n          height: this.hostElement.nativeElement.clientHeight\n        });\n        this.canvasStore.setDpr(((_a = this.document.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) || 1);\n        this.canvasStore.initRendererEffect(this.rendererCanvas.nativeElement);\n        this.canvasStore.initSceneEffect(this.scene);\n        this.canvasStore.initCameraEffect(this.camera);\n        this.canvasStore.initRaycasterEffect(this.raycaster);\n        this.initWindowResizeListener();\n        this.initActiveListener();\n      });\n    }\n\n    initWindowResizeListener() {\n      var _a;\n\n      if ((_a = this.document) === null || _a === void 0 ? void 0 : _a.defaultView) {\n        fromEvent(this.document.defaultView, 'resize').pipe(takeUntil(this.destroyed)).subscribe(() => {\n          this.ngZone.runOutsideAngular(() => {\n            var _a;\n\n            this.canvasStore.windowResizeEffect({\n              size: {\n                width: this.hostElement.nativeElement.clientWidth,\n                height: this.hostElement.nativeElement.clientHeight\n              },\n              dpr: ((_a = this.document.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) || 1\n            });\n          });\n        });\n      }\n    }\n\n    initActiveListener() {\n      this.canvasStore.active$.pipe(takeUntil(this.destroyed), observeOn(asapScheduler)).subscribe(active => {\n        this.ngZone.runOutsideAngular(() => {\n          if (active) {\n            const {\n              renderer,\n              camera,\n              scene\n            } = this.canvasStore.getImperativeState();\n\n            if (renderer && camera && scene) {\n              this.created.emit({\n                gl: renderer,\n                camera,\n                scene\n              });\n              this.eventsStore.connectEffect(renderer.domElement);\n              this.loopService.start();\n            }\n          }\n        });\n      });\n    }\n\n  }\n\n  CanvasComponent.ɵfac = function CanvasComponent_Factory(t) {\n    return new (t || CanvasComponent)(i0.ɵɵdirectiveInject(CanvasStore, 2), i0.ɵɵdirectiveInject(AnimationStore, 2), i0.ɵɵdirectiveInject(EventsStore, 2), i0.ɵɵdirectiveInject(LoopService, 2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(DestroyedService));\n  };\n\n  CanvasComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CanvasComponent,\n    selectors: [[\"ngt-canvas\"]],\n    viewQuery: function CanvasComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rendererCanvas = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function CanvasComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"ngt-canvas\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      orthographic: \"orthographic\",\n      linear: \"linear\",\n      shadows: \"shadows\",\n      camera: \"camera\",\n      scene: \"scene\",\n      raycaster: \"raycaster\"\n    },\n    outputs: {\n      created: \"created\"\n    },\n    exportAs: [\"ngtCanvas\"],\n    features: [i0.ɵɵProvidersFeature([CanvasStore, EventsStore, InstancesStore, AnimationStore, LoopService, DestroyedService])],\n    decls: 2,\n    vars: 0,\n    consts: [[\"rendererCanvas\", \"\"]],\n    template: function CanvasComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"canvas\", null, 0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] {\\n        display: block;\\n        position: relative;\\n        width: 100%;\\n        height: 100%;\\n        overflow: hidden;\\n      }\\n\\n      [_nghost-%COMP%]   canvas[_ngcontent-%COMP%] {\\n        display: block;\\n      }\"],\n    changeDetection: 0\n  });\n  return CanvasComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet Controller = /*#__PURE__*/(() => {\n  class Controller {\n    constructor() {\n      this.change$ = new ReplaySubject(1);\n    }\n\n    ngOnChanges(changes) {\n      this.change$.next(changes);\n    }\n\n  }\n\n  Controller.ɵfac = function Controller_Factory(t) {\n    return new (t || Controller)();\n  };\n\n  Controller.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Controller,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return Controller;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // GENERATED\n\n\nlet Object3dControllerDirective = /*#__PURE__*/(() => {\n  class Object3dControllerDirective extends Controller {\n    constructor() {\n      super(...arguments);\n      this.castShadow = false;\n      this.receiveShadow = false;\n      this.visible = true;\n      this.matrixAutoUpdate = true;\n      this.appendMode = 'immediate'; // events\n\n      this.click = new EventEmitter();\n      this.contextmenu = new EventEmitter();\n      this.dblclick = new EventEmitter();\n      this.pointerup = new EventEmitter();\n      this.pointerdown = new EventEmitter();\n      this.pointerover = new EventEmitter();\n      this.pointerout = new EventEmitter();\n      this.pointerenter = new EventEmitter();\n      this.pointerleave = new EventEmitter();\n      this.pointermove = new EventEmitter();\n      this.pointermissed = new EventEmitter();\n      this.pointercancel = new EventEmitter();\n      this.wheel = new EventEmitter();\n    }\n\n  }\n\n  Object3dControllerDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵObject3dControllerDirective_BaseFactory;\n    return function Object3dControllerDirective_Factory(t) {\n      return (ɵObject3dControllerDirective_BaseFactory || (ɵObject3dControllerDirective_BaseFactory = i0.ɵɵgetInheritedFactory(Object3dControllerDirective)))(t || Object3dControllerDirective);\n    };\n  }();\n\n  Object3dControllerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Object3dControllerDirective,\n    selectors: [[\"ngt-primitive\", \"o3d\", \"\"], [\"ngt-mesh\", \"o3d\", \"\"], [\"ngt-instanced-mesh\", \"o3d\", \"\"], [\"ngt-skinned-mesh\", \"o3d\", \"\"], [\"ngt-bone\", \"o3d\", \"\"], [\"ngt-group\", \"o3d\", \"\"], [\"ngt-lod\", \"o3d\", \"\"], [\"ngt-scene\", \"o3d\", \"\"], [\"ngt-points\", \"o3d\", \"\"], [\"ngt-cube-camera\", \"o3d\", \"\"], [\"ngt-contact-shadows\", \"o3d\", \"\"], [\"ngt-html\", \"o3d\", \"\"], [\"ngt-light-probe\", \"o3d\", \"\"], [\"ngt-ambient-light\", \"o3d\", \"\"], [\"ngt-ambient-light-probe\", \"o3d\", \"\"], [\"ngt-hemisphere-light\", \"o3d\", \"\"], [\"ngt-hemisphere-light-probe\", \"o3d\", \"\"], [\"ngt-directional-light\", \"o3d\", \"\"], [\"ngt-point-light\", \"o3d\", \"\"], [\"ngt-spot-light\", \"o3d\", \"\"], [\"ngt-rect-area-light\", \"o3d\", \"\"], [\"ngt-arrow-helper\", \"o3d\", \"\"], [\"ngt-axes-helper\", \"o3d\", \"\"], [\"ngt-box-helper\", \"o3d\", \"\"], [\"ngt-box3-helper\", \"o3d\", \"\"], [\"ngt-grid-helper\", \"o3d\", \"\"], [\"ngt-camera-helper\", \"o3d\", \"\"], [\"ngt-directional-light-helper\", \"o3d\", \"\"], [\"ngt-hemisphere-light-helper\", \"o3d\", \"\"], [\"ngt-plane-helper\", \"o3d\", \"\"], [\"ngt-point-light-helper\", \"o3d\", \"\"], [\"ngt-polar-grid-helper\", \"o3d\", \"\"], [\"ngt-skeleton-helper\", \"o3d\", \"\"], [\"ngt-spot-light-helper\", \"o3d\", \"\"], [\"ngt-line\", \"o3d\", \"\"], [\"ngt-line-loop\", \"o3d\", \"\"], [\"ngt-line-segments\", \"o3d\", \"\"], [\"ngt-sprite\", \"o3d\", \"\"], [\"ngt-camera\", \"o3d\", \"\"], [\"ngt-perspective-camera\", \"o3d\", \"\"], [\"ngt-orthographic-camera\", \"o3d\", \"\"], [\"ngt-array-camera\", \"o3d\", \"\"], [\"ngt-stereo-camera\", \"o3d\", \"\"]],\n    inputs: {\n      name: \"name\",\n      position: \"position\",\n      rotation: \"rotation\",\n      quaternion: \"quaternion\",\n      scale: \"scale\",\n      color: \"color\",\n      userData: \"userData\",\n      dispose: \"dispose\",\n      castShadow: \"castShadow\",\n      receiveShadow: \"receiveShadow\",\n      visible: \"visible\",\n      matrixAutoUpdate: \"matrixAutoUpdate\",\n      appendMode: \"appendMode\",\n      appendTo: \"appendTo\"\n    },\n    outputs: {\n      click: \"click\",\n      contextmenu: \"contextmenu\",\n      dblclick: \"dblclick\",\n      pointerup: \"pointerup\",\n      pointerdown: \"pointerdown\",\n      pointerover: \"pointerover\",\n      pointerout: \"pointerout\",\n      pointerenter: \"pointerenter\",\n      pointerleave: \"pointerleave\",\n      pointermove: \"pointermove\",\n      pointermissed: \"pointermissed\",\n      pointercancel: \"pointercancel\",\n      wheel: \"wheel\"\n    },\n    exportAs: [\"ngtObject3dController\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return Object3dControllerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeCoreModule = /*#__PURE__*/(() => {\n  class ThreeCoreModule {}\n\n  ThreeCoreModule.ɵfac = function ThreeCoreModule_Factory(t) {\n    return new (t || ThreeCoreModule)();\n  };\n\n  ThreeCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ThreeCoreModule\n  });\n  ThreeCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ThreeCoreModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst OBJECT_3D_WATCHED_CONTROLLER = new InjectionToken('Watched Object3D Controller');\nconst OBJECT_3D_CONTROLLER_PROVIDER = [DestroyedService, {\n  provide: OBJECT_3D_WATCHED_CONTROLLER,\n  deps: [[new Optional(), Object3dControllerDirective], ChangeDetectorRef, DestroyedService],\n  useFactory: object3dWatchedControllerFactory\n}];\n\nfunction object3dWatchedControllerFactory(controller, changeDetectorRef, destroy$) {\n  if (!controller) return null;\n  controller.change$.pipe(takeUntil(destroy$)).subscribe(() => {\n    changeDetectorRef.markForCheck();\n  });\n  return controller;\n}\n\nlet AnimationLoopParticipant = /*#__PURE__*/(() => {\n  class AnimationLoopParticipant {\n    constructor(animationStore, ngZone) {\n      this.animationStore = animationStore;\n      this.ngZone = ngZone;\n      this.animateReady = new EventEmitter();\n    }\n\n    participate(animateObject) {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.animateReady.observed) {\n          if (animateObject instanceof Object3D) {\n            this.animateTeardown = this.animationStore.registerAnimation(animateObject, (obj, state) => {\n              this.animateReady.emit({\n                animateObject: obj,\n                renderState: state\n              });\n            });\n          } else {\n            this.animateTeardown = this.animationStore.registerAnimation(state => {\n              this.animateReady.emit({\n                animateObject,\n                renderState: state\n              });\n            });\n          }\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.animateTeardown) {\n          this.animateTeardown();\n        }\n      });\n    }\n\n  }\n\n  AnimationLoopParticipant.ɵfac = function AnimationLoopParticipant_Factory(t) {\n    return new (t || AnimationLoopParticipant)(i0.ɵɵdirectiveInject(AnimationStore), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  AnimationLoopParticipant.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AnimationLoopParticipant,\n    outputs: {\n      animateReady: \"animateReady\"\n    }\n  });\n  return AnimationLoopParticipant;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeObject3d = /*#__PURE__*/(() => {\n  class ThreeObject3d extends AnimationLoopParticipant {\n    constructor(object3dController, canvasStore, instancesStore, eventsStore, animationStore, ngZone, parentObjectDirective) {\n      super(animationStore, ngZone);\n      this.object3dController = object3dController;\n      this.canvasStore = canvasStore;\n      this.instancesStore = instancesStore;\n      this.eventsStore = eventsStore;\n      this.animationStore = animationStore;\n      this.ngZone = ngZone;\n      this.parentObjectDirective = parentObjectDirective;\n      this.$object3d = new BehaviorSubject(null);\n      this.ready = this.object3d$.pipe(filter(Boolean));\n      this.changesSubscription = object3dController.change$.subscribe(() => {\n        if (this.object3d) {\n          this.applyCustomProps();\n        }\n\n        if (this.inputChangeHandler) {\n          this.inputChangeHandler();\n        }\n      });\n    }\n\n    get object3d$() {\n      return this.$object3d.asObservable();\n    }\n\n    ngOnChanges() {\n      if (this.object3d) {\n        this.applyCustomProps();\n      }\n    }\n\n    init() {\n      this.ngZone.runOutsideAngular(() => {\n        this.initObject();\n\n        if (this.object3d) {\n          this.applyCustomProps();\n          applyProps(this.object3d, {\n            __ngt: {\n              canvasStateGetter: () => this.canvasStore.getImperativeState(),\n              eventsStateGetter: () => this.eventsStore.getImperativeState(),\n              handlers: this.applyEvents()\n            }\n          });\n          this.instancesStore.saveObject(this.object3d);\n          this.appendToParent();\n          this.objectReady();\n        }\n      });\n    }\n\n    addToScene() {\n      const {\n        scene\n      } = this.canvasStore.getImperativeState();\n\n      if (scene) {\n        scene.add(this.object3d);\n      }\n    }\n\n    addToParent() {\n      if (this.parentObjectDirective) {\n        this.parentObjectDirective.object3d.add(this.object3d);\n      } else {\n        this.addToScene();\n      }\n    }\n\n    remove() {\n      if (this.object3dController.appendTo) {\n        this.object3dController.appendTo.remove(this.object3d);\n      } else if (this.parentObjectDirective && this.object3dController.appendMode === 'immediate') {\n        this.parentObjectDirective.object3d.remove(this.object3d);\n      } else {\n        const {\n          scene\n        } = this.canvasStore.getImperativeState();\n\n        if (scene) {\n          scene.remove(this.object3d);\n        }\n      }\n\n      this.object3d.clear();\n    }\n\n    objectReady() {\n      this.$object3d.next(this.object3d);\n      this.participate(this.object3d);\n    }\n\n    applyCustomProps() {\n      this.ngZone.runOutsideAngular(() => {\n        const customProps = {\n          castShadow: this.object3dController.castShadow,\n          receiveShadow: this.object3dController.receiveShadow,\n          visible: this.object3dController.visible,\n          matrixAutoUpdate: this.object3dController.matrixAutoUpdate\n        };\n\n        if (this.object3dController.name) {\n          customProps['name'] = this.object3dController.name;\n        }\n\n        if (this.object3dController.position) {\n          customProps['position'] = this.object3dController.position;\n        }\n\n        if (this.object3dController.rotation) {\n          customProps['rotation'] = this.object3dController.rotation;\n        } else if (this.object3dController.quaternion) {\n          customProps['quaternion'] = this.object3dController.quaternion;\n        }\n\n        if (this.object3dController.scale) {\n          customProps['scale'] = this.object3dController.scale;\n        }\n\n        if (this.object3dController.userData) {\n          customProps['userData'] = this.object3dController.userData;\n        }\n\n        if (this.object3dController.color) {\n          this.object3dController.color = Array.isArray(this.object3dController.color) ? new Color(...this.object3dController.color) : new Color(this.object3dController.color);\n\n          if (!this.canvasStore.getImperativeState().isLinear) {\n            this.object3dController.color.convertSRGBToLinear();\n          }\n\n          customProps['color'] = this.object3dController.color;\n        }\n\n        if (this.object3dController.dispose) {\n          customProps['dispose'] = this.object3dController.dispose;\n        }\n\n        this.object3dController.change$.pipe(take(1)).subscribe(changes => {\n          if (changes) {\n            for (const [inputName, inputChange] of Object.entries(changes)) {\n              if (!inputChange.isFirstChange() || ['name', 'position', 'rotation', 'quaternion', 'scale', 'userData', 'color', 'dispose', 'castShadow', 'receiveShadow', 'visible', 'matrixAutoUpdate'].includes(inputName) // skip 12 common inputs\n              ) {\n                continue;\n              }\n\n              customProps[inputName] = inputChange.currentValue;\n            }\n          }\n        });\n        applyProps(this.object3d, customProps);\n        this.object3d.updateMatrix();\n      });\n    }\n\n    applyEvents() {\n      const handlers = {};\n      ['click', 'contextmenu', 'dblclick', 'pointerup', 'pointerdown', 'pointerover', 'pointerout', 'pointerenter', 'pointerleave', 'pointermove', 'pointermissed', 'pointercancel', 'wheel'].forEach(eventName => {\n        if (this.object3dController[eventName].observed) {\n          handlers[eventName] = event => {\n            this.ngZone.run(() => {\n              this.object3dController[eventName].emit(event);\n            });\n          };\n        }\n      });\n      return handlers;\n    }\n\n    appendToParent() {\n      if (this.object3dController.appendTo) {\n        this.object3dController.appendTo.add(this.object3d);\n        return;\n      }\n\n      if (this.object3dController.appendMode === 'root') {\n        this.addToScene();\n        return;\n      }\n\n      if (this.object3dController.appendMode === 'immediate') {\n        this.addToParent();\n      }\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n\n      if (this.changesSubscription) {\n        this.changesSubscription.unsubscribe();\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        if (this.object3d) {\n          this.remove();\n          this.instancesStore.removeObject(this.object3d.uuid);\n          this.animationStore.unregisterAnimationEffect(this.object3d.uuid);\n        }\n      });\n    }\n\n  }\n\n  ThreeObject3d.ɵfac = function ThreeObject3d_Factory(t) {\n    return new (t || ThreeObject3d)(i0.ɵɵdirectiveInject(OBJECT_3D_WATCHED_CONTROLLER), i0.ɵɵdirectiveInject(CanvasStore), i0.ɵɵdirectiveInject(InstancesStore), i0.ɵɵdirectiveInject(EventsStore), i0.ɵɵdirectiveInject(AnimationStore), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ThreeObject3d, 12));\n  };\n\n  ThreeObject3d.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeObject3d,\n    outputs: {\n      ready: \"ready\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return ThreeObject3d;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeObject3dMaterialGeometry = /*#__PURE__*/(() => {\n  class ThreeObject3dMaterialGeometry extends ThreeObject3d {\n    set extraArgs(v) {\n      this._extraArgs = v;\n    }\n\n    ngAfterContentInit() {\n      this.init();\n    }\n\n    initObject() {\n      if (this.canCreate()) {\n        const material = this.getMaterial();\n        const geometry = this.getGeometry();\n        this._objectMaterialGeometry = new this.objectType(geometry, material, ...(this._extraArgs || []));\n\n        if (this.morphTargetDictionary && 'morphTargetDictionary' in this._objectMaterialGeometry) {\n          this._objectMaterialGeometry.morphTargetDictionary = this.morphTargetDictionary;\n        }\n\n        if (this.morphTargetInfluences && 'morphTargetInfluences' in this._objectMaterialGeometry) {\n          this._objectMaterialGeometry.morphTargetInfluences = this.morphTargetInfluences;\n        }\n\n        if (this.customize) {\n          this.customize();\n        }\n      }\n    }\n\n    canCreate() {\n      return true;\n    }\n\n    get object3d() {\n      return this._objectMaterialGeometry;\n    }\n\n    getMaterial() {\n      if (this.material) {\n        if (Array.isArray(this.material) && this.material[0] instanceof Material || this.material instanceof Material) {\n          return this.material;\n        }\n\n        if (Array.isArray(this.material)) {\n          return this.material.map(materialId => this.instancesStore.getImperativeState().materials[materialId]);\n        }\n\n        return this.instancesStore.getImperativeState().materials[this.material];\n      }\n\n      return undefined;\n    }\n\n    getGeometry() {\n      if (this.geometry) {\n        if (this.geometry instanceof BufferGeometry) {\n          return this.geometry;\n        }\n\n        return this.instancesStore.getImperativeState().bufferGeometries[this.geometry];\n      }\n\n      return undefined;\n    }\n\n  }\n\n  ThreeObject3dMaterialGeometry.ɵfac = /* @__PURE__ */function () {\n    let ɵThreeObject3dMaterialGeometry_BaseFactory;\n    return function ThreeObject3dMaterialGeometry_Factory(t) {\n      return (ɵThreeObject3dMaterialGeometry_BaseFactory || (ɵThreeObject3dMaterialGeometry_BaseFactory = i0.ɵɵgetInheritedFactory(ThreeObject3dMaterialGeometry)))(t || ThreeObject3dMaterialGeometry);\n    };\n  }();\n\n  ThreeObject3dMaterialGeometry.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeObject3dMaterialGeometry,\n    inputs: {\n      geometry: \"geometry\",\n      material: \"material\",\n      morphTargetInfluences: \"morphTargetInfluences\",\n      morphTargetDictionary: \"morphTargetDictionary\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ThreeObject3dMaterialGeometry;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeMaterial = /*#__PURE__*/(() => {\n  class ThreeMaterial {\n    constructor(ngZone, instancesStore, canvasStore) {\n      this.ngZone = ngZone;\n      this.instancesStore = instancesStore;\n      this.canvasStore = canvasStore;\n    }\n\n    set parameters(v) {\n      this._parameters = v;\n\n      if (v && this.material) {\n        this.ngZone.runOutsideAngular(() => {\n          this.convertColorToLinear(v);\n          this.material.setValues(v);\n          this.material.needsUpdate = true;\n        });\n      }\n    }\n\n    get parameters() {\n      return this._parameters;\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.parameters) {\n          this.convertColorToLinear(this.parameters);\n        }\n\n        this._material = new this.materialType(this.parameters);\n        this.instancesStore.saveMaterial({\n          id: this.ngtId,\n          material: this._material\n        });\n      });\n    }\n\n    get material() {\n      return this._material;\n    }\n\n    convertColorToLinear(parameters) {\n      if ('color' in parameters) {\n        const colorParams = parameters['color'];\n        parameters['color'] = Array.isArray(colorParams) ? new Color(...colorParams) : new Color(colorParams);\n\n        if (!this.canvasStore.getImperativeState().isLinear) {\n          parameters['color'].convertSRGBToLinear();\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.material) {\n          this.instancesStore.removeMaterial(this.ngtId || this.material.uuid);\n          this.material.dispose();\n        }\n      });\n    }\n\n  }\n\n  ThreeMaterial.ɵfac = function ThreeMaterial_Factory(t) {\n    return new (t || ThreeMaterial)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(InstancesStore, 4), i0.ɵɵdirectiveInject(CanvasStore, 4));\n  };\n\n  ThreeMaterial.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeMaterial,\n    inputs: {\n      ngtId: \"ngtId\",\n      parameters: \"parameters\"\n    }\n  });\n  return ThreeMaterial;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeTexture = /*#__PURE__*/(() => {\n  class ThreeTexture {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this._extraArgs = [];\n    }\n\n    set extraArgs(v) {\n      this._extraArgs = v;\n      this.ngZone.runOutsideAngular(() => {\n        this._texture = new this.textureType(...this._extraArgs);\n      });\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        if (!this.texture) {\n          this._texture = new this.textureType(...this._extraArgs);\n        }\n      });\n    }\n\n    get texture() {\n      return this._texture;\n    }\n\n    ngOnDestroy() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.texture) {\n          this.texture.dispose();\n        }\n      });\n    }\n\n  }\n\n  ThreeTexture.ɵfac = function ThreeTexture_Factory(t) {\n    return new (t || ThreeTexture)(i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ThreeTexture.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeTexture\n  });\n  return ThreeTexture;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeLight = /*#__PURE__*/(() => {\n  class ThreeLight extends ThreeObject3d {\n    constructor() {\n      super(...arguments);\n      this._extraArgs = [];\n    }\n\n    set extraArgs(v) {\n      this._extraArgs = v;\n      this.ngZone.runOutsideAngular(() => {\n        this.init();\n      });\n    }\n\n    ngOnInit() {\n      if (!this.object3d) {\n        this.init();\n      }\n    }\n\n    initObject() {\n      if (this.intensity) {\n        this._extraArgs[1] = this.intensity;\n      }\n\n      this._light = new this.lightType(...this._extraArgs);\n    }\n\n    get object3d() {\n      return this._light;\n    }\n\n  }\n\n  ThreeLight.ɵfac = /* @__PURE__ */function () {\n    let ɵThreeLight_BaseFactory;\n    return function ThreeLight_Factory(t) {\n      return (ɵThreeLight_BaseFactory || (ɵThreeLight_BaseFactory = i0.ɵɵgetInheritedFactory(ThreeLight)))(t || ThreeLight);\n    };\n  }();\n\n  ThreeLight.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeLight,\n    inputs: {\n      intensity: \"intensity\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ThreeLight;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeHelper = /*#__PURE__*/(() => {\n  class ThreeHelper extends ThreeObject3d {\n    constructor() {\n      super(...arguments);\n      this._extraArgs = [];\n\n      this.inputChangeHandler = () => {\n        if (!this.object3d) {\n          this.init();\n        }\n      };\n    }\n\n    set extraArgs(v) {\n      this._extraArgs = v;\n      this.ngZone.runOutsideAngular(() => {\n        this.init();\n      });\n    }\n\n    ngOnChanges() {\n      super.ngOnChanges();\n      this.inputChangeHandler();\n    }\n\n    ngOnInit() {\n      this.inputChangeHandler();\n    }\n\n    initObject() {\n      try {\n        this._helper = new this.helperType(...this._extraArgs);\n      } catch (e) {\n        console.log('Failed to initialize Helper');\n      }\n    }\n\n    get object3d() {\n      return this._helper;\n    }\n\n  }\n\n  ThreeHelper.ɵfac = /* @__PURE__ */function () {\n    let ɵThreeHelper_BaseFactory;\n    return function ThreeHelper_Factory(t) {\n      return (ɵThreeHelper_BaseFactory || (ɵThreeHelper_BaseFactory = i0.ɵɵgetInheritedFactory(ThreeHelper)))(t || ThreeHelper);\n    };\n  }();\n\n  ThreeHelper.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeHelper,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return ThreeHelper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeBufferGeometry = /*#__PURE__*/(() => {\n  class ThreeBufferGeometry {\n    constructor(instancesStore, ngZone) {\n      this.instancesStore = instancesStore;\n      this.ngZone = ngZone;\n      this._extraArgs = [];\n    }\n\n    set extraArgs(v) {\n      this._extraArgs = v;\n      this.ngZone.runOutsideAngular(() => {\n        this.init();\n      });\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        if (!this.bufferGeometry) {\n          this.init();\n        }\n      });\n    }\n\n    init() {\n      this._bufferGeometry = new this.geometryType(...this._extraArgs);\n      this.instancesStore.saveBufferGeometry({\n        id: this.ngtId,\n        bufferGeometry: this._bufferGeometry\n      });\n    }\n\n    get bufferGeometry() {\n      return this._bufferGeometry;\n    }\n\n    ngOnDestroy() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.bufferGeometry) {\n          this.instancesStore.removeBufferGeometry(this.ngtId || this.bufferGeometry.uuid);\n          this.bufferGeometry.dispose();\n        }\n      });\n    }\n\n  }\n\n  ThreeBufferGeometry.ɵfac = function ThreeBufferGeometry_Factory(t) {\n    return new (t || ThreeBufferGeometry)(i0.ɵɵdirectiveInject(InstancesStore, 4), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ThreeBufferGeometry.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeBufferGeometry,\n    inputs: {\n      ngtId: \"ngtId\"\n    }\n  });\n  return ThreeBufferGeometry;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeCurve = /*#__PURE__*/(() => {\n  class ThreeCurve {\n    constructor(ngZone, geometryDirective) {\n      this.ngZone = ngZone;\n      this.geometryDirective = geometryDirective;\n      this._extraArgs = [];\n    }\n\n    set extraArgs(v) {\n      this._extraArgs = v;\n      this.ngZone.runOutsideAngular(() => {\n        this.init();\n      });\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        if (!this.curve) {\n          this.init();\n        }\n      });\n    }\n\n    init() {\n      this._curve = new this.curveType(...this._extraArgs);\n\n      if (this.curve && this.geometryDirective) {\n        const points = this.curve.getPoints(this.divisions);\n        this.geometryDirective.bufferGeometry.setFromPoints(points);\n      }\n    }\n\n    get curve() {\n      return this._curve;\n    }\n\n  }\n\n  ThreeCurve.ɵfac = function ThreeCurve_Factory(t) {\n    return new (t || ThreeCurve)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ThreeBufferGeometry, 8));\n  };\n\n  ThreeCurve.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeCurve,\n    inputs: {\n      divisions: \"divisions\"\n    }\n  });\n  return ThreeCurve;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeAttribute = /*#__PURE__*/(() => {\n  class ThreeAttribute {\n    constructor(ngZone, geometryDirective) {\n      this.ngZone = ngZone;\n      this.geometryDirective = geometryDirective;\n      this._extraArgs = [];\n    }\n\n    set extraArgs(v) {\n      this._extraArgs = v;\n      this.ngZone.runOutsideAngular(() => {\n        this.init();\n      });\n    }\n\n    ngOnChanges() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.attribute) {\n          this.attribute.needsUpdate = true;\n        }\n      });\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        if (!this.attribute) {\n          this.init();\n        }\n      });\n    }\n\n    init() {\n      if (this.geometryDirective && this.attach) {\n        this._attribute = new this.attributeType(...this._extraArgs);\n\n        if (this.attribute) {\n          this.geometryDirective.bufferGeometry.setAttribute(this.attach, this.attribute);\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.geometryDirective && this.attach) {\n          this.geometryDirective.bufferGeometry.deleteAttribute(this.attach);\n        }\n      });\n    }\n\n    get attribute() {\n      return this._attribute;\n    }\n\n  }\n\n  ThreeAttribute.ɵfac = function ThreeAttribute_Factory(t) {\n    return new (t || ThreeAttribute)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ThreeBufferGeometry, 8));\n  };\n\n  ThreeAttribute.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeAttribute,\n    inputs: {\n      attach: \"attach\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return ThreeAttribute;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeLine = /*#__PURE__*/(() => {\n  class ThreeLine extends ThreeObject3dMaterialGeometry {\n    set materialDirectives(v) {\n      if (this.material == null && v) {\n        this.material = v.length === 1 ? v.first.material : v.toArray().map(dir => dir.material);\n      }\n    }\n\n    set bufferGeometryDirective(v) {\n      if (this.geometry == null) {\n        this.geometry = v.bufferGeometry;\n      }\n    }\n\n    get objectType() {\n      return this.lineType;\n    }\n\n  }\n\n  ThreeLine.ɵfac = /* @__PURE__ */function () {\n    let ɵThreeLine_BaseFactory;\n    return function ThreeLine_Factory(t) {\n      return (ɵThreeLine_BaseFactory || (ɵThreeLine_BaseFactory = i0.ɵɵgetInheritedFactory(ThreeLine)))(t || ThreeLine);\n    };\n  }();\n\n  ThreeLine.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeLine,\n    contentQueries: function ThreeLine_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ThreeBufferGeometry, 5);\n        i0.ɵɵcontentQuery(dirIndex, ThreeMaterial, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.bufferGeometryDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.materialDirectives = _t);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ThreeLine;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeMesh = /*#__PURE__*/(() => {\n  class ThreeMesh extends ThreeObject3dMaterialGeometry {\n    set materialDirectives(v) {\n      if (this.material == null && v) {\n        this.material = v.length === 1 ? v.first.material : v.toArray().map(dir => dir.material);\n      }\n    }\n\n    set bufferGeometryDirective(v) {\n      if (this.geometry == null && v) {\n        this.geometry = v.bufferGeometry;\n      }\n    }\n\n    get objectType() {\n      return this.meshType;\n    }\n\n  }\n\n  ThreeMesh.ɵfac = /* @__PURE__ */function () {\n    let ɵThreeMesh_BaseFactory;\n    return function ThreeMesh_Factory(t) {\n      return (ɵThreeMesh_BaseFactory || (ɵThreeMesh_BaseFactory = i0.ɵɵgetInheritedFactory(ThreeMesh)))(t || ThreeMesh);\n    };\n  }();\n\n  ThreeMesh.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeMesh,\n    contentQueries: function ThreeMesh_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ThreeBufferGeometry, 5);\n        i0.ɵɵcontentQuery(dirIndex, ThreeMaterial, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.bufferGeometryDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.materialDirectives = _t);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ThreeMesh;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeSprite = /*#__PURE__*/(() => {\n  class ThreeSprite extends ThreeObject3d {\n    ngAfterContentInit() {\n      this.init();\n    }\n\n    initObject() {\n      if (this.material) {\n        this._sprite = new this.spriteType(this.material);\n        return;\n      }\n\n      if (this.materialDirective) {\n        if (this.materialDirective.material instanceof SpriteMaterial) {\n          this._sprite = new this.spriteType(this.materialDirective.material);\n          return;\n        }\n\n        console.warn(`Sprite can only be instantiated with SpriteMaterial`);\n      }\n    }\n\n    get object3d() {\n      return this._sprite;\n    }\n\n  }\n\n  ThreeSprite.ɵfac = /* @__PURE__ */function () {\n    let ɵThreeSprite_BaseFactory;\n    return function ThreeSprite_Factory(t) {\n      return (ɵThreeSprite_BaseFactory || (ɵThreeSprite_BaseFactory = i0.ɵɵgetInheritedFactory(ThreeSprite)))(t || ThreeSprite);\n    };\n  }();\n\n  ThreeSprite.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeSprite,\n    contentQueries: function ThreeSprite_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ThreeMaterial, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.materialDirective = _t.first);\n      }\n    },\n    inputs: {\n      material: \"material\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ThreeSprite;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeCamera = /*#__PURE__*/(() => {\n  class ThreeCamera extends ThreeObject3d {\n    constructor() {\n      super(...arguments);\n      this._extraArgs = [];\n    }\n\n    set extraArgs(v) {\n      this._extraArgs = v;\n      this.ngZone.runOutsideAngular(() => {\n        this.init();\n      });\n    }\n\n    ngOnInit() {\n      if (!this.object3d) {\n        this.init();\n      }\n    }\n\n    initObject() {\n      this._camera = new this.cameraType(...this._extraArgs);\n    }\n\n    get object3d() {\n      return this._camera;\n    }\n\n  }\n\n  ThreeCamera.ɵfac = /* @__PURE__ */function () {\n    let ɵThreeCamera_BaseFactory;\n    return function ThreeCamera_Factory(t) {\n      return (ɵThreeCamera_BaseFactory || (ɵThreeCamera_BaseFactory = i0.ɵɵgetInheritedFactory(ThreeCamera)))(t || ThreeCamera);\n    };\n  }();\n\n  ThreeCamera.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThreeCamera,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ThreeCamera;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PrimitiveDirective = /*#__PURE__*/(() => {\n  class PrimitiveDirective extends AnimationLoopParticipant {\n    constructor(animationStore, ngZone, object3dController, canvasStore, parentObjectDirective) {\n      super(animationStore, ngZone);\n      this.animationStore = animationStore;\n      this.ngZone = ngZone;\n      this.object3dController = object3dController;\n      this.canvasStore = canvasStore;\n      this.parentObjectDirective = parentObjectDirective;\n      this.ready = new EventEmitter();\n    }\n\n    get object() {\n      return this._object;\n    }\n\n    set object(value) {\n      if (value == null) {\n        console.error('[object] is required');\n      }\n\n      this._object = value;\n\n      if (value) {\n        this.ready.emit(value);\n        this.participate(value);\n      }\n    }\n\n    get object3d() {\n      return this._object;\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        this.appendToParent();\n      });\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this.ngZone.runOutsideAngular(() => {\n        if (this.object3d) {\n          this.remove();\n        }\n      });\n    }\n\n    appendToParent() {\n      if (this.object3d && this.object3d instanceof Object3D) {\n        if (this.object3dController.appendTo) {\n          this.object3dController.appendTo.add(this.object3d);\n          return;\n        }\n\n        const {\n          scene\n        } = this.canvasStore.getImperativeState();\n\n        if (this.object3dController.appendMode === 'root') {\n          if (scene) {\n            scene.add(this.object3d);\n          }\n\n          return;\n        }\n\n        if (this.object3dController.appendMode === 'immediate') {\n          if (this.parentObjectDirective) {\n            this.parentObjectDirective.object3d.add(this.object3d);\n          } else {\n            if (scene) {\n              scene.add(this.object3d);\n            }\n          }\n        }\n      }\n    }\n\n    remove() {\n      if (this.object3d instanceof Object3D) {\n        if (this.object3dController.appendTo) {\n          this.object3dController.appendTo.remove(this.object3d);\n        } else if (this.parentObjectDirective && this.object3dController.appendMode === 'immediate') {\n          this.parentObjectDirective.object3d.remove(this.object3d);\n        } else {\n          const {\n            scene\n          } = this.canvasStore.getImperativeState();\n\n          if (scene) {\n            scene.remove(this.object3d);\n          }\n        }\n\n        this.object3d.clear();\n      }\n    }\n\n  }\n\n  PrimitiveDirective.ɵfac = function PrimitiveDirective_Factory(t) {\n    return new (t || PrimitiveDirective)(i0.ɵɵdirectiveInject(AnimationStore), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(OBJECT_3D_WATCHED_CONTROLLER), i0.ɵɵdirectiveInject(CanvasStore), i0.ɵɵdirectiveInject(ThreeObject3d, 12));\n  };\n\n  PrimitiveDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PrimitiveDirective,\n    selectors: [[\"ngt-primitive\"]],\n    inputs: {\n      object: \"object\"\n    },\n    outputs: {\n      ready: \"ready\"\n    },\n    exportAs: [\"ngtPrimitive\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ThreeObject3d,\n      useExisting: PrimitiveDirective\n    }, OBJECT_3D_CONTROLLER_PROVIDER]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return PrimitiveDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreePrimitiveModule = /*#__PURE__*/(() => {\n  class ThreePrimitiveModule {}\n\n  ThreePrimitiveModule.ɵfac = function ThreePrimitiveModule_Factory(t) {\n    return new (t || ThreePrimitiveModule)();\n  };\n\n  ThreePrimitiveModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ThreePrimitiveModule\n  });\n  ThreePrimitiveModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ThreePrimitiveModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MathPipe = /*#__PURE__*/(() => {\n  class MathPipe {\n    transform(value, keyOfMath) {\n      const params = Array.isArray(value) ? value : [value];\n      return Math[keyOfMath](...params);\n    }\n\n  }\n\n  MathPipe.ɵfac = function MathPipe_Factory(t) {\n    return new (t || MathPipe)();\n  };\n\n  MathPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"math\",\n    type: MathPipe,\n    pure: true\n  });\n  return MathPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeMathPipeModule = /*#__PURE__*/(() => {\n  class ThreeMathPipeModule {}\n\n  ThreeMathPipeModule.ɵfac = function ThreeMathPipeModule_Factory(t) {\n    return new (t || ThreeMathPipeModule)();\n  };\n\n  ThreeMathPipeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ThreeMathPipeModule\n  });\n  ThreeMathPipeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ThreeMathPipeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MathConstantPipe = /*#__PURE__*/(() => {\n  class MathConstantPipe {\n    transform(value, keyOfMathConst) {\n      if (keyOfMathConst === 'random') {\n        return Math.random();\n      }\n\n      return value * Math[keyOfMathConst];\n    }\n\n  }\n\n  MathConstantPipe.ɵfac = function MathConstantPipe_Factory(t) {\n    return new (t || MathConstantPipe)();\n  };\n\n  MathConstantPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"mathConst\",\n    type: MathConstantPipe,\n    pure: true\n  });\n  return MathConstantPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeMathConstantPipeModule = /*#__PURE__*/(() => {\n  class ThreeMathConstantPipeModule {}\n\n  ThreeMathConstantPipeModule.ɵfac = function ThreeMathConstantPipeModule_Factory(t) {\n    return new (t || ThreeMathConstantPipeModule)();\n  };\n\n  ThreeMathConstantPipeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ThreeMathConstantPipeModule\n  });\n  ThreeMathConstantPipeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ThreeMathConstantPipeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ColorPipe = /*#__PURE__*/(() => {\n  class ColorPipe {\n    /**\n     * ConstructorParameters<typeof THREE.Color> has a limitation on THREE.Color constructor overloads\n     */\n    transform(args) {\n      return new THREE.Color(...args);\n    }\n\n  }\n\n  ColorPipe.ɵfac = function ColorPipe_Factory(t) {\n    return new (t || ColorPipe)();\n  };\n\n  ColorPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"color\",\n    type: ColorPipe,\n    pure: true\n  });\n  return ColorPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeColorPipeModule = /*#__PURE__*/(() => {\n  class ThreeColorPipeModule {}\n\n  ThreeColorPipeModule.ɵfac = function ThreeColorPipeModule_Factory(t) {\n    return new (t || ThreeColorPipeModule)();\n  };\n\n  ThreeColorPipeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ThreeColorPipeModule\n  });\n  ThreeColorPipeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ThreeColorPipeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FogPipe = /*#__PURE__*/(() => {\n  class FogPipe {\n    transform(args) {\n      return new THREE.Fog(...args);\n    }\n\n  }\n\n  FogPipe.ɵfac = function FogPipe_Factory(t) {\n    return new (t || FogPipe)();\n  };\n\n  FogPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"fog\",\n    type: FogPipe,\n    pure: true\n  });\n  return FogPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeFogPipeModule = /*#__PURE__*/(() => {\n  class ThreeFogPipeModule {}\n\n  ThreeFogPipeModule.ɵfac = function ThreeFogPipeModule_Factory(t) {\n    return new (t || ThreeFogPipeModule)();\n  };\n\n  ThreeFogPipeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ThreeFogPipeModule\n  });\n  ThreeFogPipeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ThreeFogPipeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MAX_VALUE = 0x10000;\nlet RepeatDirective = /*#__PURE__*/(() => {\n  class RepeatDirective {\n    constructor(viewContainer, templateRef) {\n      this.viewContainer = viewContainer;\n      this.templateRef = templateRef;\n    }\n\n    set repeatOf(count) {\n      const safeCount = Math.floor(Math.max(0, Math.min(count, MAX_VALUE)));\n      const {\n        length\n      } = this.viewContainer;\n\n      if (safeCount < length) {\n        this.removeContainers(length - safeCount);\n      } else {\n        this.addContainers(length, safeCount);\n      }\n    }\n\n    addContainers(length, count) {\n      for (let index = length; index < count; index++) {\n        this.viewContainer.createEmbeddedView(this.templateRef, {\n          $implicit: index,\n          isFirst: index === length,\n          isLast: index === count - 1,\n          isOdd: !(index % 2),\n          isEven: !!(index % 2)\n        });\n      }\n    }\n\n    removeContainers(amount) {\n      for (let index = 0; index < amount; index++) {\n        this.viewContainer.remove();\n      }\n    }\n\n    static ngTemplateContextGuard(dir, ctx) {\n      return true;\n    }\n\n  }\n\n  RepeatDirective.ɵfac = function RepeatDirective_Factory(t) {\n    return new (t || RepeatDirective)(i0.ɵɵdirectiveInject(ViewContainerRef), i0.ɵɵdirectiveInject(TemplateRef));\n  };\n\n  RepeatDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RepeatDirective,\n    selectors: [[\"\", \"repeat\", \"\", \"repeatOf\", \"\"]],\n    inputs: {\n      repeatOf: \"repeatOf\"\n    }\n  });\n  return RepeatDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThreeRepeatModule = /*#__PURE__*/(() => {\n  class ThreeRepeatModule {}\n\n  ThreeRepeatModule.ɵfac = function ThreeRepeatModule_Factory(t) {\n    return new (t || ThreeRepeatModule)();\n  };\n\n  ThreeRepeatModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ThreeRepeatModule\n  });\n  ThreeRepeatModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ThreeRepeatModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AnimationLoopParticipant, AnimationStore, CanvasComponent, CanvasStore, ColorPipe, Controller, DestroyedService, EventsStore, FogPipe, InstancesStore, LoaderService, LoopService, MathConstantPipe, MathPipe, OBJECT_3D_CONTROLLER_PROVIDER, OBJECT_3D_WATCHED_CONTROLLER, Object3dControllerDirective, PrimitiveDirective, RepeatDirective, ThreeAttribute, ThreeBufferGeometry, ThreeCamera, ThreeColorPipeModule, ThreeCoreModule, ThreeCurve, ThreeFogPipeModule, ThreeHelper, ThreeLight, ThreeLine, ThreeMaterial, ThreeMathConstantPipeModule, ThreeMathPipeModule, ThreeMesh, ThreeObject3d, ThreeObject3dMaterialGeometry, ThreePrimitiveModule, ThreeRepeatModule, ThreeSprite, ThreeTexture, applyProps, isOrthographicCamera, object3dWatchedControllerFactory }; //# sourceMappingURL=angular-three-core.js.map","map":null,"metadata":{},"sourceType":"module"}