{"ast":null,"code":"import * as THREE from 'three';\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport fragmentShader from '../../../assets/shaders/fragment-shader.glsl';\nimport vertexShader from '../../../assets/shaders/vertex-shader.glsl';\nimport { Float32BufferAttribute, SphereGeometry, Vector3 } from 'three';\nimport * as i0 from \"@angular/core\";\nconst _c0 = [\"dom\"];\nexport let SphereComponent = /*#__PURE__*/(() => {\n  class SphereComponent {\n    constructor() {\n      this.texture = new THREE.TextureLoader().load('../assets/images/flower01.jpg');\n      this.radius = 1;\n      this.widthSegments = 32;\n      this.heightSegments = 16;\n      this.phiStart = 0;\n      this.phiLength = Math.PI * 2;\n      this.thetaStart = 0;\n      this.thetaLength = Math.PI;\n      this.time = 0;\n      this.scene = new THREE.Scene(); // this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n      // this.camera.position.z = 3;\n\n      this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);\n      this.camera.position.z = 50;\n      this.renderer = new THREE.WebGLRenderer({\n        antialias: true // alpha: true\n\n      });\n      this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n      this.resize();\n      this.setupResize();\n      this.addObjects();\n      this.addSecondObject();\n      this.render(); // super();\n\n      this.type = 'SphereGeometry';\n      this.parameters = {\n        radius: this.radius,\n        widthSegments: this.widthSegments,\n        heightSegments: this.heightSegments,\n        phiStart: this.phiStart,\n        phiLength: this.phiLength,\n        thetaStart: this.thetaStart,\n        thetaLength: this.thetaLength\n      };\n      this.widthSegments = Math.max(3, Math.floor(this.widthSegments));\n      this.heightSegments = Math.max(2, Math.floor(this.heightSegments));\n      const thetaEnd = Math.min(this.thetaStart + this.thetaLength, Math.PI);\n      let index = 0;\n      const grid = [];\n      const vertex = new Vector3();\n      const normal = new Vector3(); // buffers\n\n      const indices = [];\n      const vertices = [];\n      const normals = [];\n      const uvs = []; // generate vertices, normals and uvs\n\n      for (let iy = 0; iy <= this.heightSegments; iy++) {\n        const verticesRow = [];\n        const v = iy / this.heightSegments; // special case for the poles\n\n        let uOffset = 0;\n\n        if (iy == 0 && this.thetaStart == 0) {\n          uOffset = 0.5 / this.widthSegments;\n        } else if (iy == this.heightSegments && thetaEnd == Math.PI) {\n          uOffset = -0.5 / this.widthSegments;\n        }\n\n        for (let ix = 0; ix <= this.widthSegments; ix++) {\n          const u = ix / this.widthSegments; // vertex\n\n          vertex.x = -this.radius * Math.cos(this.phiStart + u * this.phiLength) * Math.sin(this.thetaStart + v * this.thetaLength);\n          vertex.y = this.radius * Math.cos(this.thetaStart + v * this.thetaLength);\n          vertex.z = this.radius * Math.sin(this.phiStart + u * this.phiLength) * Math.sin(this.thetaStart + v * this.thetaLength);\n          vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n          normal.copy(vertex).normalize();\n          normals.push(normal.x, normal.y, normal.z); // uv\n\n          uvs.push(u + uOffset, 1 - v);\n          verticesRow.push(index++);\n        }\n\n        grid.push(verticesRow);\n      } // indices\n\n\n      for (let iy = 0; iy < this.heightSegments; iy++) {\n        for (let ix = 0; ix < this.widthSegments; ix++) {\n          const a = grid[iy][ix + 1];\n          const b = grid[iy][ix];\n          const c = grid[iy + 1][ix];\n          const d = grid[iy + 1][ix + 1];\n          if (iy !== 0 || this.thetaStart > 0) indices.push(a, b, d);\n          if (iy !== this.heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n        }\n      } // build geometry\n\n\n      this.type.setIndex(indices);\n      this.type.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n      this.type.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      this.type.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    }\n\n    ngOnInit() {\n      this.onPageLoad();\n    }\n\n    ngAfterViewInit() {\n      this.renderer.setSize(window.innerWidth, window.innerHeight);\n      this.dom.nativeElement.appendChild(this.renderer.domElement);\n    }\n\n    onPageLoad() {// this.dom.nativeElement.getElementById('dom');\n      // this.dom = options.dom;\n    }\n\n    setupResize() {\n      window.addEventListener('resize', this.resize.bind(this));\n    }\n\n    resize() {\n      this.renderer.setSize(window.innerWidth, window.innerHeight);\n      this.camera.aspect = window.innerWidth / window.innerHeight;\n      this.camera.updateProjectionMatrix();\n    }\n\n    addObjects() {\n      /** Flat cube */\n      // this.geometry = new THREE.PlaneBufferGeometry( 100, 100, 10, 10 );\n\n      /** Flat Sphere */\n      this.geometry = new THREE.SphereBufferGeometry(0.4, 40, 40);\n      this.material = new THREE.MeshNormalMaterial();\n      this.material = new THREE.ShaderMaterial({\n        uniforms: {\n          time: {\n            value: 0\n          } // imageTexture: {value: this.texture},\n\n        },\n        side: THREE.DoubleSide,\n        fragmentShader: fragmentShader,\n        vertexShader: vertexShader,\n        wireframe: true\n      });\n      this.mesh = new THREE.Mesh(this.geometry, this.material);\n      this.scene.add(this.mesh);\n      console.log(this.mesh);\n    }\n\n    addSecondObject() {\n      const geometry = new THREE.SphereGeometry(15, 32, 16); // create a simple square shape. We duplicate the top left and bottom right\n      // vertices because each vertex needs to appear once per triangle.\n\n      const vertices = new Float32Array([-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0]); // itemSize = 3 because there are 3 values (components) per vertex\n\n      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n      const material = new THREE.MeshBasicMaterial({\n        color: 0xffff00\n      });\n      const mesh = new THREE.Mesh(geometry, material); // this.setPositionSecondObj(this.mesh);\n\n      this.scene.add(mesh);\n    }\n\n    setPositionSecondObj(mesh) {\n      console.log(mesh);\n      mesh.position.z += 0.05;\n      mesh.position.y += 1.075;\n      mesh.position.x += 0.05;\n    }\n\n    render() {\n      this.time += 0.5;\n      this.mesh.rotation.x = this.time / 1000;\n      this.mesh.rotation.y = this.time / 1000;\n      this.material.uniforms.time.value = this.time;\n      this.renderer.render(this.scene, this.camera);\n      window.requestAnimationFrame(this.render.bind(this));\n    }\n\n    static fromJSON(data) {\n      return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n    }\n\n  }\n\n  SphereComponent.ɵfac = function SphereComponent_Factory(t) {\n    return new (t || SphereComponent)();\n  };\n\n  SphereComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: SphereComponent,\n    selectors: [[\"app-sphere\"]],\n    viewQuery: function SphereComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dom = _t.first);\n      }\n    },\n    decls: 2,\n    vars: 0,\n    consts: [[\"id\", \"dom\"], [\"dom\", \"\"]],\n    template: function SphereComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0, 1);\n      }\n    },\n    styles: [\"\"]\n  });\n  return SphereComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}