(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('three'), require('@ngrx/component-store')) :
    typeof define === 'function' && define.amd ? define('@angular-three/core', ['exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators', 'three', '@ngrx/component-store'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["angular-three"] = global["angular-three"] || {}, global["angular-three"].core = {}), global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators, global.three, global["@ngrx/component-store"]));
})(this, (function (exports, i0, common, rxjs, operators, THREE, componentStore) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /**
     * Generate a random Id or an Event's uuid
     *
     * @param {ThreeIntersection} event
     *
     * @internal
     * @private
     */
    function makeId(event) {
        if (event) {
            return (event.eventObject || event.object).uuid + '/' + event.index;
        }
        return id();
    }
    var cache = {};
    /**
     * Generates a short id.
     *
     * Description:
     *  A 5-character alphanumeric sequence (364 = 1.6 million)
     *  This should only be used for JavaScript specific models.
     *  http://stackoverflow.com/questions/6248666/how-to-generate-short-uid-like-ax4j9z-in-js
     *
     *  Example: `aebgf`
     */
    function id() {
        var newId = ('0000' + ((Math.random() * Math.pow(36, 4)) << 0).toString(36)).slice(-4);
        newId = "a" + newId;
        // ensure not already used
        if (!cache[newId]) {
            cache[newId] = true;
            return newId;
        }
        return id();
    }

    /**
     * From r3f https://github.com/pmndrs/react-three-fiber/blob/master/packages/fiber/src/core/events.ts
     */
    function createEvents(canvasStateGetter, eventsStateGetter, instancesStateGetter) {
        var temp = new THREE.Vector3();
        /** Sets up defaultRaycaster */
        function prepareRay(event) {
            var _a, _b;
            var _e = canvasStateGetter(), raycaster = _e.raycaster, mouse = _e.mouse, camera = _e.camera, clock = _e.clock, renderer = _e.renderer, scene = _e.scene, _f = _e.internal, size = _f.size, viewport = _f.viewport;
            var delta = clock.getDelta();
            if (raycaster && camera && renderer && scene) {
                var _g = (_b = (_a = raycaster.computeOffsets) === null || _a === void 0 ? void 0 : _a.call(raycaster, event, {
                    camera: camera,
                    clock: clock,
                    size: size,
                    viewport: viewport,
                    renderer: renderer,
                    scene: scene,
                    delta: delta,
                    mouse: mouse,
                })) !== null && _b !== void 0 ? _b : event, offsetX = _g.offsetX, offsetY = _g.offsetY;
                var width = size.width, height = size.height;
                mouse.set((offsetX / width) * 2 - 1, -(offsetY / height) * 2 + 1);
                raycaster.setFromCamera(mouse, camera);
            }
        }
        /** Calculates delta */
        function calculateDistance(event) {
            var initialClick = eventsStateGetter().internal.initialClick;
            var dx = event.offsetX - initialClick[0];
            var dy = event.offsetY - initialClick[1];
            return Math.round(Math.sqrt(dx * dx + dy * dy));
        }
        /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */
        function filterPointerEvents(objects) {
            return objects.filter(function (obj) { return ['move', 'over', 'enter', 'out', 'leave'].some(function (name) {
                var _a, _b;
                return (_b = (_a = obj.__ngt) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b[('pointer' + name)];
            }); });
        }
        function intersect(filter) {
            var e_1, _e;
            var _a;
            var raycaster = canvasStateGetter().raycaster;
            var objects = instancesStateGetter().objects;
            // Skip event handling when noEvents is set
            if (!raycaster || (raycaster && !raycaster.enabled))
                return [];
            var seen = new Set();
            var intersections = [];
            // Allow callers to eliminate event objects
            var eventsObjects = filter
                ? filter(Object.values(objects))
                : Object.values(objects);
            // Intersect known handler objects and filter against duplicates
            var intersects = raycaster
                .intersectObjects(eventsObjects, true)
                .filter(function (item) {
                var id = makeId(item);
                if (seen.has(id))
                    return false;
                seen.add(id);
                return true;
            });
            try {
                // https://github.com/mrdoob/three.js/issues/16031
                // Allow custom userland intersect sort order
                // if (raycaster.filter) intersects = raycaster.filter(intersects, state);
                for (var intersects_1 = __values(intersects), intersects_1_1 = intersects_1.next(); !intersects_1_1.done; intersects_1_1 = intersects_1.next()) {
                    var intersect_1 = intersects_1_1.value;
                    var eventObject = intersect_1.object;
                    // Bubble event up
                    while (eventObject) {
                        var handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;
                        if (handlers)
                            intersections.push(Object.assign(Object.assign({}, intersect_1), { eventObject: eventObject }));
                        eventObject = eventObject.parent;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (intersects_1_1 && !intersects_1_1.done && (_e = intersects_1.return)) _e.call(intersects_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return intersections;
        }
        /**  Creates filtered intersects and returns an array of positive hits */
        function patchIntersects(intersections, event) {
            var capturedMap = eventsStateGetter().internal.capturedMap;
            // If the interaction is captured take that into account, the captured event has to be part of the intersects
            if ('pointerId' in event && capturedMap.has(event.pointerId)) {
                intersections.push.apply(intersections, __spreadArray([], __read(capturedMap.get(event.pointerId).values())));
            }
            return intersections;
        }
        /**  Handles intersections by forwarding them to handlers */
        function handleIntersects(intersections, event, callback) {
            var e_2, _e;
            var _f = canvasStateGetter(), raycaster = _f.raycaster, mouse = _f.mouse, camera = _f.camera;
            var eventsInternal = eventsStateGetter().internal;
            // If anything has been found, forward it to the event listeners
            if (intersections.length && camera) {
                var unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);
                var delta = event.type === 'click' ? calculateDistance(event) : 0;
                var releasePointerCapture = function (id) { return event.target.releasePointerCapture(id); };
                var localState_1 = { stopped: false };
                var _loop_1 = function (hit) {
                    var hasPointerCapture = function (id) { var _a, _b; return (_b = (_a = eventsInternal.capturedMap.get(id)) === null || _a === void 0 ? void 0 : _a.has(hit.eventObject)) !== null && _b !== void 0 ? _b : false; };
                    var setPointerCapture = function (id) {
                        if (eventsInternal.capturedMap.has(id)) {
                            // if the pointerId was previously captured, we add the hit to the
                            // event capturedMap.
                            eventsInternal.capturedMap.get(id).set(hit.eventObject, hit);
                        }
                        else {
                            // if the pointerId was not previously captured, we create a map
                            // containing the hitObject, and the hit. hitObject is used for
                            // faster access.
                            eventsInternal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));
                        }
                        // Call the original event now
                        event.target.setPointerCapture(id);
                    };
                    // Add native event props
                    var extractEventProps = {};
                    for (var prop in Object.getPrototypeOf(event)) {
                        // noinspection JSUnfilteredForInLoop
                        var property = event[prop];
                        // Only copy over atomics, leave functions alone as these should be
                        // called as event.nativeEvent.fn()
                        if (typeof property !== 'function') {
                            // noinspection JSUnfilteredForInLoop
                            extractEventProps[prop] = property;
                        }
                    }
                    var raycastEvent = Object.assign(Object.assign(Object.assign({}, hit), extractEventProps), { spaceX: mouse.x, spaceY: mouse.y, intersections: intersections, stopped: localState_1.stopped, delta: delta, unprojectedPoint: unprojectedPoint, ray: raycaster ? raycaster.ray : null, camera: camera, 
                        // Hijack stopPropagation, which just sets a flag
                        stopPropagation: function () {
                            // https://github.com/pmndrs/react-three-fiber/issues/596
                            // Events are not allowed to stop propagation if the pointer has been captured
                            var capturesForPointer = 'pointerId' in event &&
                                eventsInternal.capturedMap.get(event.pointerId);
                            // We only authorize stopPropagation...
                            if (
                            // ...if this pointer hasn't been captured
                            !capturesForPointer ||
                                // ... or if the hit object is capturing the pointer
                                capturesForPointer.has(hit.eventObject)) {
                                raycastEvent.stopped = localState_1.stopped = true;
                                // Propagation is stopped, remove all other hover records
                                // An event handler is only allowed to flush other handlers if it is hovered itself
                                if (eventsInternal.hovered.size &&
                                    Array.from(eventsInternal.hovered.values()).find(function (i) { return i.eventObject === hit.eventObject; })) {
                                    // Objects cannot flush out higher up objects that have already caught the event
                                    var higher = intersections.slice(0, intersections.indexOf(hit));
                                    cancelPointer(__spreadArray(__spreadArray([], __read(higher)), [hit]));
                                }
                            }
                        }, target: Object.assign(Object.assign({}, event.target), { setPointerCapture: setPointerCapture, releasePointerCapture: releasePointerCapture, hasPointerCapture: hasPointerCapture }), currentTarget: Object.assign(Object.assign({}, event.currentTarget), { setPointerCapture: setPointerCapture, releasePointerCapture: releasePointerCapture, hasPointerCapture: hasPointerCapture }), sourceEvent: event, nativeEvent: event });
                    // Call subscribers
                    callback(raycastEvent);
                    // Event bubbling may be interrupted by stopPropagation
                    if (localState_1.stopped)
                        return "break";
                };
                try {
                    for (var intersections_1 = __values(intersections), intersections_1_1 = intersections_1.next(); !intersections_1_1.done; intersections_1_1 = intersections_1.next()) {
                        var hit = intersections_1_1.value;
                        var state_1 = _loop_1(hit);
                        if (state_1 === "break")
                            break;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (intersections_1_1 && !intersections_1_1.done && (_e = intersections_1.return)) _e.call(intersections_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            return intersections;
        }
        function cancelPointer(hits) {
            var internal = eventsStateGetter().internal;
            Array.from(internal.hovered.values()).forEach(function (hoveredObj) {
                var _a, _b, _c;
                // When no objects were hit or the the hovered object wasn't found underneath the cursor
                // we call onPointerOut and delete the object from the hovered-elements map
                if (!hits.length ||
                    !hits.find(function (hit) { return hit.object === hoveredObj.object && hit.index === hoveredObj.index; })) {
                    var eventObject = hoveredObj.eventObject;
                    var handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;
                    internal.hovered.delete(makeId(hoveredObj));
                    if (handlers) {
                        // Clear out intersects, they are outdated by now
                        var data = Object.assign(Object.assign({}, hoveredObj), { intersections: hits || [] });
                        (_b = handlers.pointerout) === null || _b === void 0 ? void 0 : _b.call(handlers, data);
                        (_c = handlers.pointerleave) === null || _c === void 0 ? void 0 : _c.call(handlers, data);
                    }
                }
            });
        }
        var handlePointer = function (name) {
            // Deal with cancellation
            switch (name) {
                case 'pointerleave':
                case 'pointercancel':
                    return function () { return cancelPointer([]); };
                case 'lostpointercapture':
                    return function (event) {
                        if ('pointerId' in event) {
                            // this will be a problem if one target releases the pointerId
                            // and another one is still keeping it, as the line below
                            // indifferently deletes all capturing references.
                            var capturedMap = eventsStateGetter().internal.capturedMap;
                            capturedMap.delete(event.pointerId);
                        }
                    };
            }
            // Any other pointer goes here ...
            return function (event) {
                var internal = eventsStateGetter().internal;
                var objects = instancesStateGetter().objects;
                prepareRay(event);
                // Get fresh intersects
                var isPointerMove = name === 'pointermove';
                var filter = isPointerMove ? filterPointerEvents : undefined;
                var hits = patchIntersects(intersect(filter), event);
                // Take care of unhover
                if (isPointerMove)
                    cancelPointer(hits);
                handleIntersects(hits, event, function (data) {
                    var _a, _b, _c, _d;
                    var eventObject = data.eventObject;
                    var handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;
                    // Check presence of handlers
                    if (!handlers)
                        return;
                    if (isPointerMove) {
                        // Move event ...
                        if (handlers.pointerover ||
                            handlers.pointerenter ||
                            handlers.pointerout ||
                            handlers.pointerleave) {
                            // When enter or out is present take care of hover-state
                            var id = makeId(data);
                            var hoveredItem = internal.hovered.get(id);
                            if (!hoveredItem) {
                                // If the object wasn't previously hovered, book it and call its handler
                                internal.hovered.set(id, data);
                                (_b = handlers.pointerover) === null || _b === void 0 ? void 0 : _b.call(handlers, data);
                                (_c = handlers.pointerenter) === null || _c === void 0 ? void 0 : _c.call(handlers, data);
                            }
                            else if (hoveredItem.stopped) {
                                // If the object was previously hovered and stopped, we shouldn't allow other items to proceed
                                data.stopPropagation();
                            }
                        }
                        // Call mouse move
                        (_d = handlers.pointermove) === null || _d === void 0 ? void 0 : _d.call(handlers, data);
                    }
                    else {
                        // All other events ...
                        var handler = handlers === null || handlers === void 0 ? void 0 : handlers[name];
                        if (handler) {
                            // Forward all events back to their respective handlers with the exception of click events,
                            // which must use the initial target
                            if ((name !== 'click' &&
                                name !== 'contextmenu' &&
                                name !== 'dblclick') ||
                                internal.initialHits.includes(eventObject)) {
                                handler(data);
                                pointerMissed(event, Object.values(objects).filter(function (object) { return object !== eventObject; }));
                            }
                        }
                    }
                });
                // Save initial coordinates on pointer-down
                if (name === 'pointerdown') {
                    internal.initialClick = [event.offsetX, event.offsetY];
                    internal.initialHits = hits.map(function (hit) { return hit.eventObject; });
                }
                // If a click yields no results, pass it back to the user as a miss
                if ((name === 'click' || name === 'contextmenu' || name === 'dblclick') &&
                    !hits.length) {
                    if (calculateDistance(event) <= 2) {
                        pointerMissed(event, Object.values(objects));
                        // if (onPointerMissed) onPointerMissed();
                    }
                }
            };
        };
        function pointerMissed(event, objects) {
            objects.forEach(function (object) {
                var _a, _b, _c;
                return (_c = (_b = (_a = object.__ngt) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.pointermissed) === null || _c === void 0 ? void 0 : _c.call(_b, event);
            });
        }
        return { handlePointer: handlePointer };
    }

    function applyDottedPathProps(instance, key, propAtKey, isRoot) {
        if (isRoot === void 0) { isRoot = true; }
        var _a = __read(key.split('.')), first = _a[0], paths = _a.slice(1);
        var rootChild = instance[first];
        if (rootChild == null) {
            return;
        }
        if (paths.length >= 1) {
            applyDottedPathProps(rootChild, paths.join('.'), propAtKey, false);
        }
        else {
            instance[first] = propAtKey;
        }
        if (isRoot) {
            checkNeedsUpdate(rootChild);
        }
    }
    function checkNeedsUpdate(value) {
        if (typeof value === 'object' && 'needsUpdate' in value) {
            value['needsUpdate'] = true;
        }
    }
    /**
     * Apply props on instances
     *
     * @internal
     * @private
     */
    function applyProps(instance, props) {
        var e_1, _a;
        if (!props || (props && !Object.keys(props).length))
            return;
        if ('__ngt' in props) {
            instance['__ngt'] = props['__ngt'];
        }
        var unknownInstance = instance;
        if (unknownInstance['set'] != null &&
            typeof unknownInstance['set'] === 'function') {
            unknownInstance['set'](props);
        }
        try {
            for (var _b = __values(Object.entries(props)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], propAtKey = _d[1];
                if (key.split('.').length > 1) {
                    applyDottedPathProps(instance, key, propAtKey);
                }
                else {
                    var threeInstancePropAtKey = unknownInstance[key];
                    if (threeInstancePropAtKey == null) {
                        unknownInstance[key] = propAtKey;
                    }
                    else {
                        if (threeInstancePropAtKey['set'] != null &&
                            typeof threeInstancePropAtKey['set'] === 'function') {
                            if (Array.isArray(propAtKey)) {
                                if (threeInstancePropAtKey['fromArray'] != null &&
                                    typeof threeInstancePropAtKey['fromArray'] === 'function') {
                                    threeInstancePropAtKey['fromArray'](propAtKey);
                                }
                                else {
                                    threeInstancePropAtKey['set'].apply(threeInstancePropAtKey, __spreadArray([], __read(propAtKey)));
                                }
                            }
                            else {
                                threeInstancePropAtKey['set'](propAtKey);
                            }
                        }
                        else {
                            unknownInstance[key] = propAtKey;
                        }
                    }
                    checkNeedsUpdate(propAtKey);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }

    var ImperativeComponentStore = /** @class */ (function (_super) {
        __extends(ImperativeComponentStore, _super);
        function ImperativeComponentStore() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ImperativeComponentStore.prototype.getImperativeState = function () {
            return this.get();
        };
        return ImperativeComponentStore;
    }(componentStore.ComponentStore));

    var AnimationStore = /** @class */ (function (_super) {
        __extends(AnimationStore, _super);
        function AnimationStore() {
            var _this = _super.call(this, {
                animations: {},
                objectSubscriptions: [],
                animationCallbacks: [],
                hasPriority: false,
            }) || this;
            _this.animationsChangedEffect = _this.effect(function (animations$) { return animations$.pipe(operators.tap(function (animations) {
                var animationCallbacks = Object.values(animations);
                var hasPriority = animationCallbacks.some(function (_c) {
                    var priority = _c.priority;
                    return !!priority;
                });
                _this.patchState({ animationCallbacks: animationCallbacks, hasPriority: hasPriority });
            })); });
            _this.unregisterAnimationEffect = _this.effect(function (uuid$) { return uuid$.pipe(operators.withLatestFrom(_this.state$), operators.tap(function (_c) {
                var _d = __read(_c, 2), uuid = _d[0], _e = _d[1], animations = _e.animations, objectSubscriptions = _e.objectSubscriptions;
                var subscription = objectSubscriptions.find(function (_c) {
                    var _d = __read(_c, 1), objectUuid = _d[0];
                    return objectUuid === uuid;
                });
                if (subscription) {
                    subscription[1].unsubscribe();
                }
                var _a = animations, _b = uuid, _ = _a[_b], updatedAnimations = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
                _this.patchState({
                    animations: updatedAnimations,
                    objectSubscriptions: objectSubscriptions.filter(function (_c) {
                        var _d = __read(_c, 1), objectUuid = _d[0];
                        return objectUuid !== uuid;
                    }),
                });
            })); });
            _this.clearEffect = _this.effect(function (trigger$) { return trigger$.pipe(operators.tap(function () {
                _this.patchState(function (state) {
                    state.objectSubscriptions.forEach(function (_c) {
                        var _d = __read(_c, 2), subscription = _d[1];
                        return subscription.unsubscribe();
                    });
                    return { animations: {}, objectSubscriptions: [] };
                });
            })); });
            _this.animationsChangedEffect(_this.select(function (s) { return s.animations; }).pipe(operators.skip(1)));
            return _this;
        }
        AnimationStore.prototype.registerAnimation = function (objOrObsOrCallback, callbackOrPriority, priority) {
            var _this = this;
            if (priority === void 0) { priority = 0; }
            if (objOrObsOrCallback === undefined)
                return;
            if (typeof objOrObsOrCallback === 'function') {
                var id_1 = makeId();
                this.patchState(function (state) {
                    var _c;
                    return (Object.assign(Object.assign({}, state), { animations: Object.assign(Object.assign({}, state.animations), (_c = {}, _c[id_1] = {
                            obj: null,
                            callback: objOrObsOrCallback,
                            priority: callbackOrPriority || 0,
                        }, _c)) }));
                });
                return function () {
                    _this.unregisterAnimationEffect(id_1);
                };
            }
            if (rxjs.isObservable(objOrObsOrCallback)) {
                var id_2 = '';
                var subscription_1 = objOrObsOrCallback
                    .pipe(operators.filter(function (obj) { return !!obj; }))
                    .subscribe(function (obj) {
                    _this.patchState(function (state) {
                        var _c;
                        var _a;
                        var objectSubscriptions = state.objectSubscriptions;
                        if ((_a = objectSubscriptions[objectSubscriptions.length - 1]) === null || _a === void 0 ? void 0 : _a[0]) {
                            objectSubscriptions[objectSubscriptions.length - 1][0] = obj.uuid;
                        }
                        id_2 = obj.uuid;
                        return {
                            animations: Object.assign(Object.assign({}, state.animations), (_c = {}, _c[id_2] = {
                                obj: obj,
                                callback: callbackOrPriority,
                                priority: priority,
                            }, _c)),
                            objectSubscriptions: objectSubscriptions,
                        };
                    });
                });
                this.patchState(function (state) { return ({
                    objectSubscriptions: __spreadArray(__spreadArray([], __read(state.objectSubscriptions)), [
                        [null, subscription_1],
                    ]),
                }); });
                return function () {
                    _this.unregisterAnimationEffect(id_2);
                };
            }
            var uuid = objOrObsOrCallback.uuid;
            this.patchState(function (state) {
                var _c;
                return ({
                    animations: Object.assign(Object.assign({}, state.animations), (_c = {}, _c[uuid] = {
                        obj: objOrObsOrCallback,
                        callback: callbackOrPriority,
                        priority: priority,
                    }, _c)),
                });
            });
            return function () {
                _this.unregisterAnimationEffect(uuid);
            };
        };
        AnimationStore.prototype.ngOnDestroy = function () {
            this.clearEffect();
            _super.prototype.ngOnDestroy.call(this);
        };
        return AnimationStore;
    }(ImperativeComponentStore));
    AnimationStore.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AnimationStore, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AnimationStore.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AnimationStore });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AnimationStore, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return []; } });

    var position = new THREE.Vector3();
    var defaultTarget = new THREE.Vector3();
    var isOrthographicCamera = function (def) { return def && def.isOrthographicCamera; };
    var CanvasStore = /** @class */ (function (_super) {
        __extends(CanvasStore, _super);
        function CanvasStore() {
            var _this = _super.call(this, {
                isOrthographic: false,
                isLinear: false,
                shadows: false,
                mouse: new THREE.Vector2(),
                clock: new THREE.Clock(),
                internal: {
                    active: false,
                    size: { width: 0, height: 0 },
                    dpr: 1,
                    viewport: {
                        initialDpr: 1,
                        dpr: 1,
                        width: 0,
                        height: 0,
                        aspect: 0,
                        distance: 0,
                        factor: 0,
                        getCurrentViewport: function (camera, target, size) {
                            if (camera === void 0) { camera = _this.getImperativeState().camera; }
                            if (target === void 0) { target = defaultTarget; }
                            if (size === void 0) { size = _this.getImperativeState().internal.size; }
                            var width = size.width, height = size.height;
                            var aspect = width / height;
                            var distance = camera
                                .getWorldPosition(position)
                                .distanceTo(target);
                            if (isOrthographicCamera(camera)) {
                                return {
                                    width: width / camera.zoom,
                                    height: height / camera.zoom,
                                    factor: 1,
                                    distance: distance,
                                    aspect: aspect,
                                };
                            }
                            var fov = (camera.fov * Math.PI) / 180; // convert vertical fov to radians
                            var h = 2 * Math.tan(fov / 2) * distance; // visible height
                            var w = h * (width / height);
                            return {
                                width: w,
                                height: h,
                                factor: width / w,
                                distance: distance,
                                aspect: aspect,
                            };
                        },
                    },
                },
            }) || this;
            _this.renderer$ = _this.select(function (s) { return s.renderer; });
            _this.camera$ = _this.select(function (s) { return s.camera; });
            _this.scene$ = _this.select(function (s) { return s.scene; });
            _this.raycaster$ = _this.select(function (s) { return s.raycaster; });
            _this.isOrthographic$ = _this.select(function (s) { return s.isOrthographic; });
            _this.isLinear$ = _this.select(function (s) { return s.isLinear; });
            _this.shadows$ = _this.select(function (s) { return s.shadows; });
            _this.active$ = _this.select(function (s) { return s.internal.active; });
            _this.canvasInternal$ = _this.select(function (s) { return s.internal; });
            _this.setIsOrthographic = _this.updater(function (state, isOrthographic) { return (Object.assign(Object.assign({}, state), { isOrthographic: isOrthographic })); });
            _this.setIsLinear = _this.updater(function (state, isLinear) { return (Object.assign(Object.assign({}, state), { isLinear: isLinear })); });
            _this.setShadows = _this.updater(function (state, shadows) { return (Object.assign(Object.assign({}, state), { shadows: shadows })); });
            _this.setSize = _this.updater(function (state, size) { return (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { size: size }) })); });
            _this.setDpr = _this.updater(function (state, dpr) { return (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { dpr: dpr }) })); });
            _this.setViewport = _this.updater(function (state) { return (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { viewport: Object.assign(Object.assign(Object.assign({}, state.internal.viewport), state.internal.viewport.getCurrentViewport(state.camera, defaultTarget, state.internal.size)), { dpr: state.internal.dpr }) }) })); });
            _this.setActive = _this.updater(function (state, active) { return (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { active: active }) })); });
            _this.initRendererEffect = _this.effect(function (canvas$) {
                return canvas$.pipe(operators.withLatestFrom(_this.canvasInternal$, _this.isLinear$, _this.shadows$), operators.tap(function (_b) {
                    var _c = __read(_b, 4), canvas = _c[0], _d = _c[1], size = _d.size, dpr = _d.dpr, isLinear = _c[2], shadows = _c[3];
                    var renderer = new THREE.WebGLRenderer({
                        canvas: canvas,
                        antialias: true,
                        powerPreference: 'high-performance',
                        alpha: true,
                    });
                    if (shadows) {
                        renderer.shadowMap.enabled = true;
                        if (typeof shadows === 'object')
                            Object.assign(renderer.shadowMap, shadows);
                        else
                            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    }
                    if (!isLinear) {
                        renderer.toneMapping = THREE.ACESFilmicToneMapping;
                        renderer.outputEncoding = THREE.sRGBEncoding;
                    }
                    renderer.setClearAlpha(0);
                    renderer.setPixelRatio(dpr);
                    renderer.setSize(size.width, size.height);
                    _this.patchState({ renderer: renderer });
                }));
            });
            _this.initSceneEffect = _this.effect(function (sceneOptions$) { return sceneOptions$.pipe(operators.tap(function (sceneOptions) {
                var scene = new THREE.Scene();
                applyProps(scene, sceneOptions);
                _this.patchState({ scene: scene });
            })); });
            _this.initCameraEffect = _this.effect(function (cameraOptions$) { return cameraOptions$.pipe(operators.withLatestFrom(_this.isOrthographic$, _this.canvasInternal$), operators.tap(function (_b) {
                var _c = __read(_b, 3), cameraOptions = _c[0], isOrthographic = _c[1], size = _c[2].size;
                var _a;
                var isCamera = cameraOptions instanceof THREE.Camera;
                var camera;
                if (isCamera) {
                    camera = cameraOptions;
                }
                else {
                    if (isOrthographic) {
                        camera = new THREE.OrthographicCamera(0, 0, 0, 0, 0.1, 1000);
                        camera.zoom = 100;
                    }
                    else {
                        camera = new THREE.PerspectiveCamera(75, (_a = size.width / size.height) !== null && _a !== void 0 ? _a : 0, 0.1, 1000);
                    }
                    camera.position.z = 5;
                    applyProps(camera, cameraOptions);
                    // Update projection matrix after applying props
                    camera.updateProjectionMatrix();
                }
                // look at center by default
                camera.lookAt(0, 0, 0);
                _this.patchState({ camera: camera });
                _this.setViewport();
            })); });
            _this.initRaycasterEffect = _this.effect(function (raycasterOptions$) { return raycasterOptions$.pipe(operators.tap(function (raycasterOptions) {
                var raycaster = new THREE.Raycaster();
                raycaster.enabled = true;
                applyProps(raycaster, raycasterOptions);
                _this.patchState({ raycaster: raycaster });
            })); });
            _this.windowResizeEffect = _this.effect(function (params$) { return params$.pipe(operators.withLatestFrom(_this.renderer$, _this.camera$), operators.tap(function (_b) {
                var _c = __read(_b, 3), _d = _c[0], dpr = _d.dpr, size = _d.size, renderer = _c[1], camera = _c[2];
                if (camera.type === 'PerspectiveCamera') {
                    camera.aspect = size.width / size.height;
                }
                else {
                    camera.left = size.width / -2;
                    camera.right = size.width / 2;
                    camera.top = size.height / 2;
                    camera.bottom = size.height / -2;
                }
                camera.updateProjectionMatrix();
                camera.updateMatrixWorld();
                renderer.setPixelRatio(dpr);
                renderer.setSize(size.width, size.height);
                _this.setSize(size);
                _this.setDpr(dpr);
                _this.setViewport();
            })); });
            _this.setActive(rxjs.combineLatest([
                _this.renderer$,
                _this.camera$,
                _this.scene$,
                _this.raycaster$,
            ]).pipe(operators.filter(function (coreObjects) { return coreObjects.every(Boolean); }), operators.mapTo(true)));
            return _this;
        }
        CanvasStore.prototype.ngOnDestroy = function () {
            var renderer = this.getImperativeState().renderer;
            if (renderer) {
                renderer.renderLists.dispose();
                renderer.forceContextLoss();
            }
            _super.prototype.ngOnDestroy.call(this);
        };
        return CanvasStore;
    }(ImperativeComponentStore));
    CanvasStore.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: CanvasStore, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CanvasStore.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: CanvasStore });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: CanvasStore, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return []; } });

    var InstancesStore = /** @class */ (function (_super) {
        __extends(InstancesStore, _super);
        function InstancesStore() {
            var _this = _super.call(this, { materials: {}, bufferGeometries: {}, objects: {} }) || this;
            _this.saveMaterial = _this.updater(function (state, _c) {
                var _d;
                var material = _c.material, _e = _c.id, id = _e === void 0 ? material.uuid : _e;
                return (Object.assign(Object.assign({}, state), { materials: Object.assign(Object.assign({}, state.materials), (_d = {}, _d[id] = material, _d)) }));
            });
            _this.removeMaterial = _this.updater(function (state, id) {
                var _a = state.materials, _b = id, _ = _a[_b], materials = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
                return Object.assign(Object.assign({}, state), { materials: materials });
            });
            _this.saveBufferGeometry = _this.updater(function (state, _c) {
                var _d;
                var bufferGeometry = _c.bufferGeometry, _e = _c.id, id = _e === void 0 ? bufferGeometry.uuid : _e;
                return (Object.assign(Object.assign({}, state), { bufferGeometries: Object.assign(Object.assign({}, state.bufferGeometries), (_d = {}, _d[id] = bufferGeometry, _d)) }));
            });
            _this.removeBufferGeometry = _this.updater(function (state, id) {
                var _a = state.bufferGeometries, _b = id, _ = _a[_b], bufferGeometries = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
                return Object.assign(Object.assign({}, state), { bufferGeometries: bufferGeometries });
            });
            _this.saveObject = _this.updater(function (state, obj) {
                var _c;
                return (Object.assign(Object.assign({}, state), { objects: Object.assign(Object.assign({}, state.objects), (_c = {}, _c[obj.uuid] = obj, _c)) }));
            });
            _this.removeObject = _this.updater(function (state, id) {
                var _a = state.objects, _b = id, _ = _a[_b], objects = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
                return Object.assign(Object.assign({}, state), { objects: objects });
            });
            return _this;
        }
        return InstancesStore;
    }(ImperativeComponentStore));
    InstancesStore.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: InstancesStore, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    InstancesStore.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: InstancesStore });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: InstancesStore, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return []; } });

    var events = {
        click: false,
        contextmenu: false,
        dblclick: false,
        wheel: true,
        pointerdown: true,
        pointerup: true,
        pointerleave: true,
        pointermove: true,
        pointercancel: true,
        lostpointercapture: true,
    };
    var EventsStore = /** @class */ (function (_super) {
        __extends(EventsStore, _super);
        function EventsStore(canvasStore, instancesStore) {
            var _this = _super.call(this, {
                connected: false,
                internal: {
                    interaction: [],
                    hovered: new Map(),
                    capturedMap: new Map(),
                    initialClick: [0, 0],
                    initialHits: [],
                },
            }) || this;
            _this.canvasStore = canvasStore;
            _this.instancesStore = instancesStore;
            _this.initHandlersEffect = _this.effect(function (trigger$) { return trigger$.pipe(operators.tap(function () {
                var handlePointer = createEvents(function () { return _this.canvasStore.getImperativeState(); }, function () { return _this.getImperativeState(); }, function () { return _this.instancesStore.getImperativeState(); }).handlePointer;
                _this.patchState({
                    handlers: Object.keys(events).reduce(function (handlers, supportedEventName) {
                        handlers[supportedEventName] = handlePointer(supportedEventName);
                        return handlers;
                    }, {}),
                });
            })); });
            _this.connectEffect = _this.effect(function (target$) { return target$.pipe(operators.tap(function (target) {
                _this.disconnectEffect();
                var handlers = _this.getImperativeState().handlers;
                _this.patchState({ connected: target });
                Object.entries(handlers !== null && handlers !== void 0 ? handlers : []).forEach(function (_a) {
                    var _b = __read(_a, 2), name = _b[0], event = _b[1];
                    var passive = events[name];
                    target.addEventListener(name, event, { passive: passive });
                });
            })); });
            _this.disconnectEffect = _this.effect(function (trigger$) { return trigger$.pipe(operators.tap(function () {
                var _a = _this.getImperativeState(), handlers = _a.handlers, connected = _a.connected;
                if (connected) {
                    Object.entries(handlers !== null && handlers !== void 0 ? handlers : []).forEach(function (_a) {
                        var _b = __read(_a, 2), name = _b[0], event = _b[1];
                        if (connected instanceof HTMLElement) {
                            connected.removeEventListener(name, event);
                        }
                    });
                    _this.patchState({ connected: false });
                }
            })); });
            _this.initHandlersEffect();
            return _this;
        }
        EventsStore.prototype.ngOnDestroy = function () {
            this.disconnectEffect();
            _super.prototype.ngOnDestroy.call(this);
        };
        return EventsStore;
    }(ImperativeComponentStore));
    EventsStore.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: EventsStore, deps: [{ token: CanvasStore }, { token: InstancesStore }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    EventsStore.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: EventsStore });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: EventsStore, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: CanvasStore }, { type: InstancesStore }]; } });

    var LoopService = /** @class */ (function () {
        // TODO: rethink limit 60fps
        // private readonly interval = 1 / 60; // 60fps;
        // private internalDelta = 0;
        function LoopService(canvasStore, animationStore) {
            this.canvasStore = canvasStore;
            this.animationStore = animationStore;
            this.loopClock = new THREE.Clock();
        }
        LoopService.prototype.start = function () {
            var _this = this;
            var renderer = this.canvasStore.getImperativeState().renderer;
            if (renderer) {
                renderer.setAnimationLoop(function () {
                    _this.tick(_this.loopClock.getDelta());
                });
            }
        };
        LoopService.prototype.stop = function () {
            var renderer = this.canvasStore.getImperativeState().renderer;
            if (renderer) {
                renderer.setAnimationLoop(null);
            }
        };
        LoopService.prototype.tick = function (delta) {
            var e_1, _a;
            // this.internalDelta += delta;
            //
            // if (this.internalDelta >= this.interval) {
            //   const {
            //     renderer,
            //     scene,
            //     camera,
            //     internal: { size, viewport },
            //     clock,
            //     mouse,
            //   } = this.canvasStore.getImperativeState();
            //   const { animationCallbacks, hasPriority } =
            //     this.animationStore.getImperativeState();
            //
            //   if (renderer && scene && camera) {
            //     if (hasPriority) {
            //       animationCallbacks.sort(
            //         ({ priority: a = 0 }, { priority: b = 0 }) => a - b
            //       );
            //     } else {
            //       renderer.render(scene, camera);
            //     }
            //
            //     const renderState = {
            //       clock,
            //       camera,
            //       scene,
            //       renderer,
            //       mouse,
            //       size,
            //       viewport,
            //       delta,
            //     };
            //     for (const animationCallback of animationCallbacks) {
            //       if (animationCallback.obj) {
            //         animationCallback.callback(animationCallback.obj, renderState);
            //       } else {
            //         animationCallback.callback(renderState);
            //       }
            //     }
            //   }
            //
            //   this.internalDelta = this.internalDelta % this.interval;
            // }
            var _b = this.canvasStore.getImperativeState(), renderer = _b.renderer, scene = _b.scene, camera = _b.camera, _c = _b.internal, size = _c.size, viewport = _c.viewport, clock = _b.clock, mouse = _b.mouse;
            var _d = this.animationStore.getImperativeState(), animationCallbacks = _d.animationCallbacks, hasPriority = _d.hasPriority;
            if (renderer && scene && camera) {
                if (hasPriority) {
                    animationCallbacks.sort(function (_a, _b) {
                        var _c = _a.priority, a = _c === void 0 ? 0 : _c;
                        var _d = _b.priority, b = _d === void 0 ? 0 : _d;
                        return a - b;
                    });
                }
                else {
                    renderer.render(scene, camera);
                }
                var renderState = {
                    clock: clock,
                    camera: camera,
                    scene: scene,
                    renderer: renderer,
                    mouse: mouse,
                    size: size,
                    viewport: viewport,
                    delta: delta,
                };
                try {
                    for (var animationCallbacks_1 = __values(animationCallbacks), animationCallbacks_1_1 = animationCallbacks_1.next(); !animationCallbacks_1_1.done; animationCallbacks_1_1 = animationCallbacks_1.next()) {
                        var animationCallback = animationCallbacks_1_1.value;
                        if (animationCallback.obj) {
                            animationCallback.callback(animationCallback.obj, renderState);
                        }
                        else {
                            animationCallback.callback(renderState);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (animationCallbacks_1_1 && !animationCallbacks_1_1.done && (_a = animationCallbacks_1.return)) _a.call(animationCallbacks_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        };
        LoopService.prototype.ngOnDestroy = function () {
            this.stop();
        };
        return LoopService;
    }());
    LoopService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: LoopService, deps: [{ token: CanvasStore }, { token: AnimationStore }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LoopService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: LoopService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: LoopService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: CanvasStore }, { type: AnimationStore }]; } });

    var DestroyedService = /** @class */ (function (_super) {
        __extends(DestroyedService, _super);
        function DestroyedService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DestroyedService.prototype.ngOnDestroy = function () {
            this.next();
            this.complete();
        };
        return DestroyedService;
    }(rxjs.Subject));
    DestroyedService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: DestroyedService, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DestroyedService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: DestroyedService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: DestroyedService, decorators: [{
                type: i0.Injectable
            }] });

    var LoaderService = /** @class */ (function () {
        function LoaderService() {
            this.cached = new Map();
        }
        LoaderService.prototype.use = function (loaderConstructor, input, extensions, onProgress) {
            var _this = this;
            var keys = (Array.isArray(input) ? input : [input]);
            var loader = new loaderConstructor();
            if (extensions) {
                extensions(loader);
            }
            var results$ = rxjs.forkJoin(keys.map(function (key) {
                if (_this.cached.has(key)) {
                    return rxjs.of(_this.cached.get(key));
                }
                return rxjs.defer(function () { return loader.loadAsync(key, onProgress); }).pipe(operators.tap(function (data) {
                    if (data.scene) {
                        Object.assign(data, _this.buildGraph(data.scene));
                    }
                    _this.cached.set(key, data);
                }), operators.catchError(function (err) {
                    console.error("Error loading " + key + ": " + err.message);
                    return rxjs.throwError(err);
                }));
            }));
            return rxjs.defer(function () { return Array.isArray(input)
                ? results$
                : results$.pipe(operators.map(function (results) { return results[0]; })); }).pipe(rxjs.shareReplay({ bufferSize: 1, refCount: true }));
        };
        LoaderService.prototype.ngOnDestroy = function () {
            this.cached.clear();
        };
        LoaderService.prototype.buildGraph = function (object) {
            var data = { nodes: {}, materials: {} };
            if (object) {
                object.traverse(function (obj) {
                    if (obj.name) {
                        data.nodes[obj.name] = obj;
                    }
                    if (obj.material &&
                        !data.materials[obj
                            .material.name]) {
                        data.materials[obj
                            .material.name] = obj.material;
                    }
                });
            }
            return data;
        };
        return LoaderService;
    }());
    LoaderService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: LoaderService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LoaderService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: LoaderService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: LoaderService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var CanvasComponent = /** @class */ (function () {
        function CanvasComponent(canvasStore, animationStore, eventsStore, loopService, ngZone, hostElement, document, destroyed) {
            this.canvasStore = canvasStore;
            this.animationStore = animationStore;
            this.eventsStore = eventsStore;
            this.loopService = loopService;
            this.ngZone = ngZone;
            this.hostElement = hostElement;
            this.document = document;
            this.destroyed = destroyed;
            this.hostClass = true;
            this.raycaster = {};
            this.created = new i0.EventEmitter();
        }
        Object.defineProperty(CanvasComponent.prototype, "orthographic", {
            set: function (v) {
                this.canvasStore.setIsOrthographic(v);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CanvasComponent.prototype, "linear", {
            set: function (v) {
                this.canvasStore.setIsLinear(v);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CanvasComponent.prototype, "shadows", {
            set: function (v) {
                this.canvasStore.setShadows(v);
            },
            enumerable: false,
            configurable: true
        });
        CanvasComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                var _a;
                _this.canvasStore.setSize({
                    width: _this.hostElement.nativeElement.clientWidth,
                    height: _this.hostElement.nativeElement.clientHeight,
                });
                _this.canvasStore.setDpr(((_a = _this.document.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) || 1);
                _this.canvasStore.initRendererEffect(_this.rendererCanvas.nativeElement);
                _this.canvasStore.initSceneEffect(_this.scene);
                _this.canvasStore.initCameraEffect(_this.camera);
                _this.canvasStore.initRaycasterEffect(_this.raycaster);
                _this.initWindowResizeListener();
                _this.initActiveListener();
            });
        };
        CanvasComponent.prototype.initWindowResizeListener = function () {
            var _this = this;
            var _a;
            if ((_a = this.document) === null || _a === void 0 ? void 0 : _a.defaultView) {
                rxjs.fromEvent(this.document.defaultView, 'resize')
                    .pipe(operators.takeUntil(this.destroyed))
                    .subscribe(function () {
                    _this.ngZone.runOutsideAngular(function () {
                        var _a;
                        _this.canvasStore.windowResizeEffect({
                            size: {
                                width: _this.hostElement.nativeElement.clientWidth,
                                height: _this.hostElement.nativeElement.clientHeight,
                            },
                            dpr: ((_a = _this.document.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) || 1,
                        });
                    });
                });
            }
        };
        CanvasComponent.prototype.initActiveListener = function () {
            var _this = this;
            this.canvasStore.active$
                .pipe(operators.takeUntil(this.destroyed), operators.observeOn(rxjs.asapScheduler))
                .subscribe(function (active) {
                _this.ngZone.runOutsideAngular(function () {
                    if (active) {
                        var _b = _this.canvasStore.getImperativeState(), renderer = _b.renderer, camera = _b.camera, scene = _b.scene;
                        if (renderer && camera && scene) {
                            _this.created.emit({ gl: renderer, camera: camera, scene: scene });
                            _this.eventsStore.connectEffect(renderer.domElement);
                            _this.loopService.start();
                        }
                    }
                });
            });
        };
        return CanvasComponent;
    }());
    CanvasComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: CanvasComponent, deps: [{ token: CanvasStore, self: true }, { token: AnimationStore, self: true }, { token: EventsStore, self: true }, { token: LoopService, self: true }, { token: i0__namespace.NgZone }, { token: i0__namespace.ElementRef }, { token: common.DOCUMENT }, { token: DestroyedService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    CanvasComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: CanvasComponent, selector: "ngt-canvas", inputs: { orthographic: "orthographic", linear: "linear", shadows: "shadows", camera: "camera", scene: "scene", raycaster: "raycaster" }, outputs: { created: "created" }, host: { properties: { "class.ngt-canvas": "this.hostClass" } }, providers: [
            CanvasStore,
            EventsStore,
            InstancesStore,
            AnimationStore,
            LoopService,
            DestroyedService,
        ], viewQueries: [{ propertyName: "rendererCanvas", first: true, predicate: ["rendererCanvas"], descendants: true, static: true }], exportAs: ["ngtCanvas"], ngImport: i0__namespace, template: " <canvas #rendererCanvas></canvas> ", isInline: true, styles: ["\n      :host {\n        display: block;\n        position: relative;\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n      }\n\n      :host canvas {\n        display: block;\n      }\n    "], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: CanvasComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ngt-canvas',
                        exportAs: 'ngtCanvas',
                        template: " <canvas #rendererCanvas></canvas> ",
                        styles: [
                            "\n      :host {\n        display: block;\n        position: relative;\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n      }\n\n      :host canvas {\n        display: block;\n      }\n    ",
                        ],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [
                            CanvasStore,
                            EventsStore,
                            InstancesStore,
                            AnimationStore,
                            LoopService,
                            DestroyedService,
                        ],
                    }]
            }], ctorParameters: function () {
            return [{ type: CanvasStore, decorators: [{
                            type: i0.Self
                        }] }, { type: AnimationStore, decorators: [{
                            type: i0.Self
                        }] }, { type: EventsStore, decorators: [{
                            type: i0.Self
                        }] }, { type: LoopService, decorators: [{
                            type: i0.Self
                        }] }, { type: i0__namespace.NgZone }, { type: i0__namespace.ElementRef }, { type: Document, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }, { type: DestroyedService }];
        }, propDecorators: { hostClass: [{
                    type: i0.HostBinding,
                    args: ['class.ngt-canvas']
                }], orthographic: [{
                    type: i0.Input
                }], linear: [{
                    type: i0.Input
                }], shadows: [{
                    type: i0.Input
                }], camera: [{
                    type: i0.Input
                }], scene: [{
                    type: i0.Input
                }], raycaster: [{
                    type: i0.Input
                }], created: [{
                    type: i0.Output
                }], rendererCanvas: [{
                    type: i0.ViewChild,
                    args: ['rendererCanvas', { static: true }]
                }] } });

    var Controller = /** @class */ (function () {
        function Controller() {
            this.change$ = new rxjs.ReplaySubject(1);
        }
        Controller.prototype.ngOnChanges = function (changes) {
            this.change$.next(changes);
        };
        return Controller;
    }());
    Controller.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Controller, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    Controller.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: Controller, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Controller, decorators: [{
                type: i0.Directive
            }] });

    var Object3dControllerDirective = /** @class */ (function (_super) {
        __extends(Object3dControllerDirective, _super);
        function Object3dControllerDirective() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.castShadow = false;
            _this.receiveShadow = false;
            _this.visible = true;
            _this.matrixAutoUpdate = true;
            _this.appendMode = 'immediate';
            // events
            _this.click = new i0.EventEmitter();
            _this.contextmenu = new i0.EventEmitter();
            _this.dblclick = new i0.EventEmitter();
            _this.pointerup = new i0.EventEmitter();
            _this.pointerdown = new i0.EventEmitter();
            _this.pointerover = new i0.EventEmitter();
            _this.pointerout = new i0.EventEmitter();
            _this.pointerenter = new i0.EventEmitter();
            _this.pointerleave = new i0.EventEmitter();
            _this.pointermove = new i0.EventEmitter();
            _this.pointermissed = new i0.EventEmitter();
            _this.pointercancel = new i0.EventEmitter();
            _this.wheel = new i0.EventEmitter();
            return _this;
        }
        return Object3dControllerDirective;
    }(Controller));
    Object3dControllerDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Object3dControllerDirective, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    Object3dControllerDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: Object3dControllerDirective, selector: "\n    ngt-primitive[o3d],\n    ngt-mesh[o3d],\n    ngt-instanced-mesh[o3d],\n    ngt-skinned-mesh[o3d],\n    ngt-bone[o3d],\n    ngt-group[o3d],\n    ngt-lod[o3d],\n    ngt-scene[o3d],\n    ngt-points[o3d],\n    ngt-cube-camera[o3d],\n    ngt-contact-shadows[o3d],\n    ngt-html[o3d],\n    ngt-light-probe[o3d],\n    ngt-ambient-light[o3d],\n    ngt-ambient-light-probe[o3d],\n    ngt-hemisphere-light[o3d],\n    ngt-hemisphere-light-probe[o3d],\n    ngt-directional-light[o3d],\n    ngt-point-light[o3d],\n    ngt-spot-light[o3d],\n    ngt-rect-area-light[o3d],\n    ngt-arrow-helper[o3d],\n    ngt-axes-helper[o3d],\n    ngt-box-helper[o3d],\n    ngt-box3-helper[o3d],\n    ngt-grid-helper[o3d],\n    ngt-camera-helper[o3d],\n    ngt-directional-light-helper[o3d],\n    ngt-hemisphere-light-helper[o3d],\n    ngt-plane-helper[o3d],\n    ngt-point-light-helper[o3d],\n    ngt-polar-grid-helper[o3d],\n    ngt-skeleton-helper[o3d],\n    ngt-spot-light-helper[o3d],\n    ngt-line[o3d],\n    ngt-line-loop[o3d],\n    ngt-line-segments[o3d],\n    ngt-sprite[o3d],\n    ngt-camera[o3d],\n    ngt-perspective-camera[o3d],\n    ngt-orthographic-camera[o3d],\n    ngt-array-camera[o3d],\n    ngt-stereo-camera[o3d]\n  ", inputs: { name: "name", position: "position", rotation: "rotation", quaternion: "quaternion", scale: "scale", color: "color", userData: "userData", dispose: "dispose", castShadow: "castShadow", receiveShadow: "receiveShadow", visible: "visible", matrixAutoUpdate: "matrixAutoUpdate", appendMode: "appendMode", appendTo: "appendTo" }, outputs: { click: "click", contextmenu: "contextmenu", dblclick: "dblclick", pointerup: "pointerup", pointerdown: "pointerdown", pointerover: "pointerover", pointerout: "pointerout", pointerenter: "pointerenter", pointerleave: "pointerleave", pointermove: "pointermove", pointermissed: "pointermissed", pointercancel: "pointercancel", wheel: "wheel" }, exportAs: ["ngtObject3dController"], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Object3dControllerDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: "\n    ngt-primitive[o3d],\n    ngt-mesh[o3d],\n    ngt-instanced-mesh[o3d],\n    ngt-skinned-mesh[o3d],\n    ngt-bone[o3d],\n    ngt-group[o3d],\n    ngt-lod[o3d],\n    ngt-scene[o3d],\n    ngt-points[o3d],\n    ngt-cube-camera[o3d],\n    ngt-contact-shadows[o3d],\n    ngt-html[o3d],\n    ngt-light-probe[o3d],\n    ngt-ambient-light[o3d],\n    ngt-ambient-light-probe[o3d],\n    ngt-hemisphere-light[o3d],\n    ngt-hemisphere-light-probe[o3d],\n    ngt-directional-light[o3d],\n    ngt-point-light[o3d],\n    ngt-spot-light[o3d],\n    ngt-rect-area-light[o3d],\n    ngt-arrow-helper[o3d],\n    ngt-axes-helper[o3d],\n    ngt-box-helper[o3d],\n    ngt-box3-helper[o3d],\n    ngt-grid-helper[o3d],\n    ngt-camera-helper[o3d],\n    ngt-directional-light-helper[o3d],\n    ngt-hemisphere-light-helper[o3d],\n    ngt-plane-helper[o3d],\n    ngt-point-light-helper[o3d],\n    ngt-polar-grid-helper[o3d],\n    ngt-skeleton-helper[o3d],\n    ngt-spot-light-helper[o3d],\n    ngt-line[o3d],\n    ngt-line-loop[o3d],\n    ngt-line-segments[o3d],\n    ngt-sprite[o3d],\n    ngt-camera[o3d],\n    ngt-perspective-camera[o3d],\n    ngt-orthographic-camera[o3d],\n    ngt-array-camera[o3d],\n    ngt-stereo-camera[o3d]\n  ",
                        exportAs: 'ngtObject3dController',
                    }]
            }], propDecorators: { name: [{
                    type: i0.Input
                }], position: [{
                    type: i0.Input
                }], rotation: [{
                    type: i0.Input
                }], quaternion: [{
                    type: i0.Input
                }], scale: [{
                    type: i0.Input
                }], color: [{
                    type: i0.Input
                }], userData: [{
                    type: i0.Input
                }], dispose: [{
                    type: i0.Input
                }], castShadow: [{
                    type: i0.Input
                }], receiveShadow: [{
                    type: i0.Input
                }], visible: [{
                    type: i0.Input
                }], matrixAutoUpdate: [{
                    type: i0.Input
                }], appendMode: [{
                    type: i0.Input
                }], appendTo: [{
                    type: i0.Input
                }], click: [{
                    type: i0.Output
                }], contextmenu: [{
                    type: i0.Output
                }], dblclick: [{
                    type: i0.Output
                }], pointerup: [{
                    type: i0.Output
                }], pointerdown: [{
                    type: i0.Output
                }], pointerover: [{
                    type: i0.Output
                }], pointerout: [{
                    type: i0.Output
                }], pointerenter: [{
                    type: i0.Output
                }], pointerleave: [{
                    type: i0.Output
                }], pointermove: [{
                    type: i0.Output
                }], pointermissed: [{
                    type: i0.Output
                }], pointercancel: [{
                    type: i0.Output
                }], wheel: [{
                    type: i0.Output
                }] } });

    var ThreeCoreModule = /** @class */ (function () {
        function ThreeCoreModule() {
        }
        return ThreeCoreModule;
    }());
    ThreeCoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeCoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ThreeCoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeCoreModule, declarations: [CanvasComponent, Object3dControllerDirective], exports: [CanvasComponent, Object3dControllerDirective] });
    ThreeCoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeCoreModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeCoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [CanvasComponent, Object3dControllerDirective],
                        exports: [CanvasComponent, Object3dControllerDirective],
                    }]
            }] });

    var OBJECT_3D_WATCHED_CONTROLLER = new i0.InjectionToken('Watched Object3D Controller');
    var OBJECT_3D_CONTROLLER_PROVIDER = [
        DestroyedService,
        {
            provide: OBJECT_3D_WATCHED_CONTROLLER,
            deps: [
                [new i0.Optional(), Object3dControllerDirective],
                i0.ChangeDetectorRef,
                DestroyedService,
            ],
            useFactory: object3dWatchedControllerFactory,
        },
    ];
    function object3dWatchedControllerFactory(controller, changeDetectorRef, destroy$) {
        if (!controller)
            return null;
        controller.change$.pipe(operators.takeUntil(destroy$)).subscribe(function () {
            changeDetectorRef.markForCheck();
        });
        return controller;
    }

    var AnimationLoopParticipant = /** @class */ (function () {
        function AnimationLoopParticipant(animationStore, ngZone) {
            this.animationStore = animationStore;
            this.ngZone = ngZone;
            this.animateReady = new i0.EventEmitter();
        }
        AnimationLoopParticipant.prototype.participate = function (animateObject) {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (_this.animateReady.observed) {
                    if (animateObject instanceof THREE.Object3D) {
                        _this.animateTeardown = _this.animationStore.registerAnimation(animateObject, function (obj, state) {
                            _this.animateReady.emit({
                                animateObject: obj,
                                renderState: state,
                            });
                        });
                    }
                    else {
                        _this.animateTeardown = _this.animationStore.registerAnimation(function (state) {
                            _this.animateReady.emit({
                                animateObject: animateObject,
                                renderState: state,
                            });
                        });
                    }
                }
            });
        };
        AnimationLoopParticipant.prototype.ngOnDestroy = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (_this.animateTeardown) {
                    _this.animateTeardown();
                }
            });
        };
        return AnimationLoopParticipant;
    }());
    AnimationLoopParticipant.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AnimationLoopParticipant, deps: [{ token: AnimationStore }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AnimationLoopParticipant.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: AnimationLoopParticipant, outputs: { animateReady: "animateReady" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AnimationLoopParticipant, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: AnimationStore }, { type: i0__namespace.NgZone }]; }, propDecorators: { animateReady: [{
                    type: i0.Output
                }] } });

    var ThreeObject3d = /** @class */ (function (_super) {
        __extends(ThreeObject3d, _super);
        function ThreeObject3d(object3dController, canvasStore, instancesStore, eventsStore, animationStore, ngZone, parentObjectDirective) {
            var _this = _super.call(this, animationStore, ngZone) || this;
            _this.object3dController = object3dController;
            _this.canvasStore = canvasStore;
            _this.instancesStore = instancesStore;
            _this.eventsStore = eventsStore;
            _this.animationStore = animationStore;
            _this.ngZone = ngZone;
            _this.parentObjectDirective = parentObjectDirective;
            _this.$object3d = new rxjs.BehaviorSubject(null);
            _this.ready = _this.object3d$.pipe(operators.filter(Boolean));
            _this.changesSubscription = object3dController.change$.subscribe(function () {
                if (_this.object3d) {
                    _this.applyCustomProps();
                }
                if (_this.inputChangeHandler) {
                    _this.inputChangeHandler();
                }
            });
            return _this;
        }
        Object.defineProperty(ThreeObject3d.prototype, "object3d$", {
            get: function () {
                return this.$object3d.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        ThreeObject3d.prototype.ngOnChanges = function () {
            if (this.object3d) {
                this.applyCustomProps();
            }
        };
        ThreeObject3d.prototype.init = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                _this.initObject();
                if (_this.object3d) {
                    _this.applyCustomProps();
                    applyProps(_this.object3d, {
                        __ngt: {
                            canvasStateGetter: function () { return _this.canvasStore.getImperativeState(); },
                            eventsStateGetter: function () { return _this.eventsStore.getImperativeState(); },
                            handlers: _this.applyEvents(),
                        },
                    });
                    _this.instancesStore.saveObject(_this.object3d);
                    _this.appendToParent();
                    _this.objectReady();
                }
            });
        };
        ThreeObject3d.prototype.addToScene = function () {
            var scene = this.canvasStore.getImperativeState().scene;
            if (scene) {
                scene.add(this.object3d);
            }
        };
        ThreeObject3d.prototype.addToParent = function () {
            if (this.parentObjectDirective) {
                this.parentObjectDirective.object3d.add(this.object3d);
            }
            else {
                this.addToScene();
            }
        };
        ThreeObject3d.prototype.remove = function () {
            if (this.object3dController.appendTo) {
                this.object3dController.appendTo.remove(this.object3d);
            }
            else if (this.parentObjectDirective &&
                this.object3dController.appendMode === 'immediate') {
                this.parentObjectDirective.object3d.remove(this.object3d);
            }
            else {
                var scene = this.canvasStore.getImperativeState().scene;
                if (scene) {
                    scene.remove(this.object3d);
                }
            }
            this.object3d.clear();
        };
        ThreeObject3d.prototype.objectReady = function () {
            this.$object3d.next(this.object3d);
            this.participate(this.object3d);
        };
        ThreeObject3d.prototype.applyCustomProps = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                var customProps = {
                    castShadow: _this.object3dController.castShadow,
                    receiveShadow: _this.object3dController.receiveShadow,
                    visible: _this.object3dController.visible,
                    matrixAutoUpdate: _this.object3dController.matrixAutoUpdate,
                };
                if (_this.object3dController.name) {
                    customProps['name'] = _this.object3dController.name;
                }
                if (_this.object3dController.position) {
                    customProps['position'] = _this.object3dController.position;
                }
                if (_this.object3dController.rotation) {
                    customProps['rotation'] = _this.object3dController.rotation;
                }
                else if (_this.object3dController.quaternion) {
                    customProps['quaternion'] = _this.object3dController.quaternion;
                }
                if (_this.object3dController.scale) {
                    customProps['scale'] = _this.object3dController.scale;
                }
                if (_this.object3dController.userData) {
                    customProps['userData'] = _this.object3dController.userData;
                }
                if (_this.object3dController.color) {
                    _this.object3dController.color = Array.isArray(_this.object3dController.color)
                        ? new (THREE.Color.bind.apply(THREE.Color, __spreadArray([void 0], __read(_this.object3dController.color))))() : new THREE.Color(_this.object3dController.color);
                    if (!_this.canvasStore.getImperativeState().isLinear) {
                        _this.object3dController.color.convertSRGBToLinear();
                    }
                    customProps['color'] = _this.object3dController.color;
                }
                if (_this.object3dController.dispose) {
                    customProps['dispose'] = _this.object3dController.dispose;
                }
                _this.object3dController.change$.pipe(operators.take(1)).subscribe(function (changes) {
                    var e_1, _a;
                    if (changes) {
                        try {
                            for (var _b = __values(Object.entries(changes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var _d = __read(_c.value, 2), inputName = _d[0], inputChange = _d[1];
                                if (!inputChange.isFirstChange() ||
                                    [
                                        'name',
                                        'position',
                                        'rotation',
                                        'quaternion',
                                        'scale',
                                        'userData',
                                        'color',
                                        'dispose',
                                        'castShadow',
                                        'receiveShadow',
                                        'visible',
                                        'matrixAutoUpdate',
                                    ].includes(inputName) // skip 12 common inputs
                                ) {
                                    continue;
                                }
                                customProps[inputName] = inputChange.currentValue;
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                });
                applyProps(_this.object3d, customProps);
                _this.object3d.updateMatrix();
            });
        };
        ThreeObject3d.prototype.applyEvents = function () {
            var _this = this;
            var handlers = {};
            [
                'click',
                'contextmenu',
                'dblclick',
                'pointerup',
                'pointerdown',
                'pointerover',
                'pointerout',
                'pointerenter',
                'pointerleave',
                'pointermove',
                'pointermissed',
                'pointercancel',
                'wheel',
            ].forEach(function (eventName) {
                if (_this.object3dController[eventName].observed) {
                    handlers[eventName] = function (event) {
                        _this.ngZone.run(function () {
                            _this.object3dController[eventName].emit(event);
                        });
                    };
                }
            });
            return handlers;
        };
        ThreeObject3d.prototype.appendToParent = function () {
            if (this.object3dController.appendTo) {
                this.object3dController.appendTo.add(this.object3d);
                return;
            }
            if (this.object3dController.appendMode === 'root') {
                this.addToScene();
                return;
            }
            if (this.object3dController.appendMode === 'immediate') {
                this.addToParent();
            }
        };
        ThreeObject3d.prototype.ngOnDestroy = function () {
            var _this = this;
            _super.prototype.ngOnDestroy.call(this);
            if (this.changesSubscription) {
                this.changesSubscription.unsubscribe();
            }
            this.ngZone.runOutsideAngular(function () {
                if (_this.object3d) {
                    _this.remove();
                    _this.instancesStore.removeObject(_this.object3d.uuid);
                    _this.animationStore.unregisterAnimationEffect(_this.object3d.uuid);
                }
            });
        };
        return ThreeObject3d;
    }(AnimationLoopParticipant));
    ThreeObject3d.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeObject3d, deps: [{ token: OBJECT_3D_WATCHED_CONTROLLER }, { token: CanvasStore }, { token: InstancesStore }, { token: EventsStore }, { token: AnimationStore }, { token: i0__namespace.NgZone }, { token: ThreeObject3d, optional: true, skipSelf: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeObject3d.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeObject3d, outputs: { ready: "ready" }, usesInheritance: true, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeObject3d, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () {
            return [{ type: Object3dControllerDirective, decorators: [{
                            type: i0.Inject,
                            args: [OBJECT_3D_WATCHED_CONTROLLER]
                        }] }, { type: CanvasStore }, { type: InstancesStore }, { type: EventsStore }, { type: AnimationStore }, { type: i0__namespace.NgZone }, { type: ThreeObject3d, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.SkipSelf
                        }] }];
        }, propDecorators: { ready: [{
                    type: i0.Output
                }] } });

    var ThreeObject3dMaterialGeometry = /** @class */ (function (_super) {
        __extends(ThreeObject3dMaterialGeometry, _super);
        function ThreeObject3dMaterialGeometry() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ThreeObject3dMaterialGeometry.prototype, "extraArgs", {
            set: function (v) {
                this._extraArgs = v;
            },
            enumerable: false,
            configurable: true
        });
        ThreeObject3dMaterialGeometry.prototype.ngAfterContentInit = function () {
            this.init();
        };
        ThreeObject3dMaterialGeometry.prototype.initObject = function () {
            var _a;
            if (this.canCreate()) {
                var material = this.getMaterial();
                var geometry = this.getGeometry();
                this._objectMaterialGeometry = new ((_a = this.objectType).bind.apply(_a, __spreadArray([void 0, geometry, material], __read((this._extraArgs || [])))))();
                if (this.morphTargetDictionary &&
                    'morphTargetDictionary' in this._objectMaterialGeometry) {
                    this._objectMaterialGeometry.morphTargetDictionary =
                        this.morphTargetDictionary;
                }
                if (this.morphTargetInfluences &&
                    'morphTargetInfluences' in this._objectMaterialGeometry) {
                    this._objectMaterialGeometry.morphTargetInfluences =
                        this.morphTargetInfluences;
                }
                if (this.customize) {
                    this.customize();
                }
            }
        };
        ThreeObject3dMaterialGeometry.prototype.canCreate = function () {
            return true;
        };
        Object.defineProperty(ThreeObject3dMaterialGeometry.prototype, "object3d", {
            get: function () {
                return this._objectMaterialGeometry;
            },
            enumerable: false,
            configurable: true
        });
        ThreeObject3dMaterialGeometry.prototype.getMaterial = function () {
            var _this = this;
            if (this.material) {
                if ((Array.isArray(this.material) &&
                    this.material[0] instanceof THREE.Material) ||
                    this.material instanceof THREE.Material) {
                    return this.material;
                }
                if (Array.isArray(this.material)) {
                    return this.material.map(function (materialId) { return _this.instancesStore.getImperativeState().materials[materialId]; });
                }
                return this.instancesStore.getImperativeState().materials[this.material];
            }
            return undefined;
        };
        ThreeObject3dMaterialGeometry.prototype.getGeometry = function () {
            if (this.geometry) {
                if (this.geometry instanceof THREE.BufferGeometry) {
                    return this.geometry;
                }
                return this.instancesStore.getImperativeState().bufferGeometries[this.geometry];
            }
            return undefined;
        };
        return ThreeObject3dMaterialGeometry;
    }(ThreeObject3d));
    ThreeObject3dMaterialGeometry.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeObject3dMaterialGeometry, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeObject3dMaterialGeometry.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeObject3dMaterialGeometry, inputs: { geometry: "geometry", material: "material", morphTargetInfluences: "morphTargetInfluences", morphTargetDictionary: "morphTargetDictionary" }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeObject3dMaterialGeometry, decorators: [{
                type: i0.Directive
            }], propDecorators: { geometry: [{
                    type: i0.Input
                }], material: [{
                    type: i0.Input
                }], morphTargetInfluences: [{
                    type: i0.Input
                }], morphTargetDictionary: [{
                    type: i0.Input
                }] } });

    var ThreeMaterial = /** @class */ (function () {
        function ThreeMaterial(ngZone, instancesStore, canvasStore) {
            this.ngZone = ngZone;
            this.instancesStore = instancesStore;
            this.canvasStore = canvasStore;
        }
        Object.defineProperty(ThreeMaterial.prototype, "parameters", {
            get: function () {
                return this._parameters;
            },
            set: function (v) {
                var _this = this;
                this._parameters = v;
                if (v && this.material) {
                    this.ngZone.runOutsideAngular(function () {
                        _this.convertColorToLinear(v);
                        _this.material.setValues(v);
                        _this.material.needsUpdate = true;
                    });
                }
            },
            enumerable: false,
            configurable: true
        });
        ThreeMaterial.prototype.ngOnInit = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (_this.parameters) {
                    _this.convertColorToLinear(_this.parameters);
                }
                _this._material = new _this.materialType(_this.parameters);
                _this.instancesStore.saveMaterial({
                    id: _this.ngtId,
                    material: _this._material,
                });
            });
        };
        Object.defineProperty(ThreeMaterial.prototype, "material", {
            get: function () {
                return this._material;
            },
            enumerable: false,
            configurable: true
        });
        ThreeMaterial.prototype.convertColorToLinear = function (parameters) {
            if ('color' in parameters) {
                var colorParams = parameters['color'];
                parameters['color'] = Array.isArray(colorParams)
                    ? new (THREE.Color.bind.apply(THREE.Color, __spreadArray([void 0], __read(colorParams))))() : new THREE.Color(colorParams);
                if (!this.canvasStore.getImperativeState().isLinear) {
                    parameters['color'].convertSRGBToLinear();
                }
            }
        };
        ThreeMaterial.prototype.ngOnDestroy = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (_this.material) {
                    _this.instancesStore.removeMaterial(_this.ngtId || _this.material.uuid);
                    _this.material.dispose();
                }
            });
        };
        return ThreeMaterial;
    }());
    ThreeMaterial.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMaterial, deps: [{ token: i0__namespace.NgZone }, { token: InstancesStore, skipSelf: true }, { token: CanvasStore, skipSelf: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeMaterial.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeMaterial, inputs: { ngtId: "ngtId", parameters: "parameters" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMaterial, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () {
            return [{ type: i0__namespace.NgZone }, { type: InstancesStore, decorators: [{
                            type: i0.SkipSelf
                        }] }, { type: CanvasStore, decorators: [{
                            type: i0.SkipSelf
                        }] }];
        }, propDecorators: { ngtId: [{
                    type: i0.Input
                }], parameters: [{
                    type: i0.Input
                }] } });

    var ThreeTexture = /** @class */ (function () {
        function ThreeTexture(ngZone) {
            this.ngZone = ngZone;
            this._extraArgs = [];
        }
        Object.defineProperty(ThreeTexture.prototype, "extraArgs", {
            set: function (v) {
                var _this = this;
                this._extraArgs = v;
                this.ngZone.runOutsideAngular(function () {
                    var _a;
                    _this._texture = new ((_a = _this.textureType).bind.apply(_a, __spreadArray([void 0], __read(_this._extraArgs))))();
                });
            },
            enumerable: false,
            configurable: true
        });
        ThreeTexture.prototype.ngOnInit = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                var _a;
                if (!_this.texture) {
                    _this._texture = new ((_a = _this.textureType).bind.apply(_a, __spreadArray([void 0], __read(_this._extraArgs))))();
                }
            });
        };
        Object.defineProperty(ThreeTexture.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: false,
            configurable: true
        });
        ThreeTexture.prototype.ngOnDestroy = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (_this.texture) {
                    _this.texture.dispose();
                }
            });
        };
        return ThreeTexture;
    }());
    ThreeTexture.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeTexture, deps: [{ token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeTexture.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeTexture, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeTexture, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.NgZone }]; } });

    var ThreeLight = /** @class */ (function (_super) {
        __extends(ThreeLight, _super);
        function ThreeLight() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this._extraArgs = [];
            return _this;
        }
        Object.defineProperty(ThreeLight.prototype, "extraArgs", {
            set: function (v) {
                var _this = this;
                this._extraArgs = v;
                this.ngZone.runOutsideAngular(function () {
                    _this.init();
                });
            },
            enumerable: false,
            configurable: true
        });
        ThreeLight.prototype.ngOnInit = function () {
            if (!this.object3d) {
                this.init();
            }
        };
        ThreeLight.prototype.initObject = function () {
            var _a;
            if (this.intensity) {
                this._extraArgs[1] = this.intensity;
            }
            this._light = new ((_a = this.lightType).bind.apply(_a, __spreadArray([void 0], __read(this._extraArgs))))();
        };
        Object.defineProperty(ThreeLight.prototype, "object3d", {
            get: function () {
                return this._light;
            },
            enumerable: false,
            configurable: true
        });
        return ThreeLight;
    }(ThreeObject3d));
    ThreeLight.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeLight, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeLight.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeLight, inputs: { intensity: "intensity" }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeLight, decorators: [{
                type: i0.Directive
            }], propDecorators: { intensity: [{
                    type: i0.Input
                }] } });

    var ThreeHelper = /** @class */ (function (_super) {
        __extends(ThreeHelper, _super);
        function ThreeHelper() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this._extraArgs = [];
            _this.inputChangeHandler = function () {
                if (!_this.object3d) {
                    _this.init();
                }
            };
            return _this;
        }
        Object.defineProperty(ThreeHelper.prototype, "extraArgs", {
            set: function (v) {
                var _this = this;
                this._extraArgs = v;
                this.ngZone.runOutsideAngular(function () {
                    _this.init();
                });
            },
            enumerable: false,
            configurable: true
        });
        ThreeHelper.prototype.ngOnChanges = function () {
            _super.prototype.ngOnChanges.call(this);
            this.inputChangeHandler();
        };
        ThreeHelper.prototype.ngOnInit = function () {
            this.inputChangeHandler();
        };
        ThreeHelper.prototype.initObject = function () {
            var _a;
            try {
                this._helper = new ((_a = this.helperType).bind.apply(_a, __spreadArray([void 0], __read(this._extraArgs))))();
            }
            catch (e) {
                console.log('Failed to initialize Helper');
            }
        };
        Object.defineProperty(ThreeHelper.prototype, "object3d", {
            get: function () {
                return this._helper;
            },
            enumerable: false,
            configurable: true
        });
        return ThreeHelper;
    }(ThreeObject3d));
    ThreeHelper.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeHelper, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeHelper.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeHelper, usesInheritance: true, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeHelper, decorators: [{
                type: i0.Directive
            }] });

    var ThreeBufferGeometry = /** @class */ (function () {
        function ThreeBufferGeometry(instancesStore, ngZone) {
            this.instancesStore = instancesStore;
            this.ngZone = ngZone;
            this._extraArgs = [];
        }
        Object.defineProperty(ThreeBufferGeometry.prototype, "extraArgs", {
            set: function (v) {
                var _this = this;
                this._extraArgs = v;
                this.ngZone.runOutsideAngular(function () {
                    _this.init();
                });
            },
            enumerable: false,
            configurable: true
        });
        ThreeBufferGeometry.prototype.ngOnInit = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (!_this.bufferGeometry) {
                    _this.init();
                }
            });
        };
        ThreeBufferGeometry.prototype.init = function () {
            var _a;
            this._bufferGeometry = new ((_a = this.geometryType).bind.apply(_a, __spreadArray([void 0], __read(this._extraArgs))))();
            this.instancesStore.saveBufferGeometry({
                id: this.ngtId,
                bufferGeometry: this._bufferGeometry,
            });
        };
        Object.defineProperty(ThreeBufferGeometry.prototype, "bufferGeometry", {
            get: function () {
                return this._bufferGeometry;
            },
            enumerable: false,
            configurable: true
        });
        ThreeBufferGeometry.prototype.ngOnDestroy = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (_this.bufferGeometry) {
                    _this.instancesStore.removeBufferGeometry(_this.ngtId || _this.bufferGeometry.uuid);
                    _this.bufferGeometry.dispose();
                }
            });
        };
        return ThreeBufferGeometry;
    }());
    ThreeBufferGeometry.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeBufferGeometry, deps: [{ token: InstancesStore, skipSelf: true }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeBufferGeometry.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeBufferGeometry, inputs: { ngtId: "ngtId" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeBufferGeometry, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () {
            return [{ type: InstancesStore, decorators: [{
                            type: i0.SkipSelf
                        }] }, { type: i0__namespace.NgZone }];
        }, propDecorators: { ngtId: [{
                    type: i0.Input
                }] } });

    var ThreeCurve = /** @class */ (function () {
        function ThreeCurve(ngZone, geometryDirective) {
            this.ngZone = ngZone;
            this.geometryDirective = geometryDirective;
            this._extraArgs = [];
        }
        Object.defineProperty(ThreeCurve.prototype, "extraArgs", {
            set: function (v) {
                var _this = this;
                this._extraArgs = v;
                this.ngZone.runOutsideAngular(function () {
                    _this.init();
                });
            },
            enumerable: false,
            configurable: true
        });
        ThreeCurve.prototype.ngOnInit = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (!_this.curve) {
                    _this.init();
                }
            });
        };
        ThreeCurve.prototype.init = function () {
            var _a;
            this._curve = new ((_a = this.curveType).bind.apply(_a, __spreadArray([void 0], __read(this._extraArgs))))();
            if (this.curve && this.geometryDirective) {
                var points = this.curve.getPoints(this.divisions);
                this.geometryDirective.bufferGeometry.setFromPoints(points);
            }
        };
        Object.defineProperty(ThreeCurve.prototype, "curve", {
            get: function () {
                return this._curve;
            },
            enumerable: false,
            configurable: true
        });
        return ThreeCurve;
    }());
    ThreeCurve.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeCurve, deps: [{ token: i0__namespace.NgZone }, { token: ThreeBufferGeometry, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeCurve.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeCurve, inputs: { divisions: "divisions" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeCurve, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () {
            return [{ type: i0__namespace.NgZone }, { type: ThreeBufferGeometry, decorators: [{
                            type: i0.Optional
                        }] }];
        }, propDecorators: { divisions: [{
                    type: i0.Input
                }] } });

    var ThreeAttribute = /** @class */ (function () {
        function ThreeAttribute(ngZone, geometryDirective) {
            this.ngZone = ngZone;
            this.geometryDirective = geometryDirective;
            this._extraArgs = [];
        }
        Object.defineProperty(ThreeAttribute.prototype, "extraArgs", {
            set: function (v) {
                var _this = this;
                this._extraArgs = v;
                this.ngZone.runOutsideAngular(function () {
                    _this.init();
                });
            },
            enumerable: false,
            configurable: true
        });
        ThreeAttribute.prototype.ngOnChanges = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (_this.attribute) {
                    _this.attribute.needsUpdate = true;
                }
            });
        };
        ThreeAttribute.prototype.ngOnInit = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (!_this.attribute) {
                    _this.init();
                }
            });
        };
        ThreeAttribute.prototype.init = function () {
            var _a;
            if (this.geometryDirective && this.attach) {
                this._attribute = new ((_a = this.attributeType).bind.apply(_a, __spreadArray([void 0], __read(this._extraArgs))))();
                if (this.attribute) {
                    this.geometryDirective.bufferGeometry.setAttribute(this.attach, this.attribute);
                }
            }
        };
        ThreeAttribute.prototype.ngOnDestroy = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                if (_this.geometryDirective && _this.attach) {
                    _this.geometryDirective.bufferGeometry.deleteAttribute(_this.attach);
                }
            });
        };
        Object.defineProperty(ThreeAttribute.prototype, "attribute", {
            get: function () {
                return this._attribute;
            },
            enumerable: false,
            configurable: true
        });
        return ThreeAttribute;
    }());
    ThreeAttribute.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeAttribute, deps: [{ token: i0__namespace.NgZone }, { token: ThreeBufferGeometry, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeAttribute.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeAttribute, inputs: { attach: "attach" }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeAttribute, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () {
            return [{ type: i0__namespace.NgZone }, { type: ThreeBufferGeometry, decorators: [{
                            type: i0.Optional
                        }] }];
        }, propDecorators: { attach: [{
                    type: i0.Input
                }] } });

    var ThreeLine = /** @class */ (function (_super) {
        __extends(ThreeLine, _super);
        function ThreeLine() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ThreeLine.prototype, "materialDirectives", {
            set: function (v) {
                if (this.material == null && v) {
                    this.material =
                        v.length === 1
                            ? v.first.material
                            : v.toArray().map(function (dir) { return dir.material; });
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThreeLine.prototype, "bufferGeometryDirective", {
            set: function (v) {
                if (this.geometry == null) {
                    this.geometry = v.bufferGeometry;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThreeLine.prototype, "objectType", {
            get: function () {
                return this.lineType;
            },
            enumerable: false,
            configurable: true
        });
        return ThreeLine;
    }(ThreeObject3dMaterialGeometry));
    ThreeLine.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeLine, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeLine.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeLine, queries: [{ propertyName: "bufferGeometryDirective", first: true, predicate: ThreeBufferGeometry, descendants: true }, { propertyName: "materialDirectives", predicate: ThreeMaterial }], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeLine, decorators: [{
                type: i0.Directive
            }], propDecorators: { materialDirectives: [{
                    type: i0.ContentChildren,
                    args: [ThreeMaterial]
                }], bufferGeometryDirective: [{
                    type: i0.ContentChild,
                    args: [ThreeBufferGeometry]
                }] } });

    var ThreeMesh = /** @class */ (function (_super) {
        __extends(ThreeMesh, _super);
        function ThreeMesh() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ThreeMesh.prototype, "materialDirectives", {
            set: function (v) {
                if (this.material == null && v) {
                    this.material =
                        v.length === 1
                            ? v.first.material
                            : v.toArray().map(function (dir) { return dir.material; });
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThreeMesh.prototype, "bufferGeometryDirective", {
            set: function (v) {
                if (this.geometry == null && v) {
                    this.geometry = v.bufferGeometry;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThreeMesh.prototype, "objectType", {
            get: function () {
                return this.meshType;
            },
            enumerable: false,
            configurable: true
        });
        return ThreeMesh;
    }(ThreeObject3dMaterialGeometry));
    ThreeMesh.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMesh, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeMesh.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeMesh, queries: [{ propertyName: "bufferGeometryDirective", first: true, predicate: ThreeBufferGeometry, descendants: true }, { propertyName: "materialDirectives", predicate: ThreeMaterial }], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMesh, decorators: [{
                type: i0.Directive
            }], propDecorators: { materialDirectives: [{
                    type: i0.ContentChildren,
                    args: [ThreeMaterial]
                }], bufferGeometryDirective: [{
                    type: i0.ContentChild,
                    args: [ThreeBufferGeometry]
                }] } });

    var ThreeSprite = /** @class */ (function (_super) {
        __extends(ThreeSprite, _super);
        function ThreeSprite() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ThreeSprite.prototype.ngAfterContentInit = function () {
            this.init();
        };
        ThreeSprite.prototype.initObject = function () {
            if (this.material) {
                this._sprite = new this.spriteType(this.material);
                return;
            }
            if (this.materialDirective) {
                if (this.materialDirective.material instanceof THREE.SpriteMaterial) {
                    this._sprite = new this.spriteType(this.materialDirective.material);
                    return;
                }
                console.warn("Sprite can only be instantiated with SpriteMaterial");
            }
        };
        Object.defineProperty(ThreeSprite.prototype, "object3d", {
            get: function () {
                return this._sprite;
            },
            enumerable: false,
            configurable: true
        });
        return ThreeSprite;
    }(ThreeObject3d));
    ThreeSprite.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeSprite, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeSprite.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeSprite, inputs: { material: "material" }, queries: [{ propertyName: "materialDirective", first: true, predicate: ThreeMaterial, descendants: true }], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeSprite, decorators: [{
                type: i0.Directive
            }], propDecorators: { material: [{
                    type: i0.Input
                }], materialDirective: [{
                    type: i0.ContentChild,
                    args: [ThreeMaterial]
                }] } });

    var ThreeCamera = /** @class */ (function (_super) {
        __extends(ThreeCamera, _super);
        function ThreeCamera() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this._extraArgs = [];
            return _this;
        }
        Object.defineProperty(ThreeCamera.prototype, "extraArgs", {
            set: function (v) {
                var _this = this;
                this._extraArgs = v;
                this.ngZone.runOutsideAngular(function () {
                    _this.init();
                });
            },
            enumerable: false,
            configurable: true
        });
        ThreeCamera.prototype.ngOnInit = function () {
            if (!this.object3d) {
                this.init();
            }
        };
        ThreeCamera.prototype.initObject = function () {
            var _a;
            this._camera = new ((_a = this.cameraType).bind.apply(_a, __spreadArray([void 0], __read(this._extraArgs))))();
        };
        Object.defineProperty(ThreeCamera.prototype, "object3d", {
            get: function () {
                return this._camera;
            },
            enumerable: false,
            configurable: true
        });
        return ThreeCamera;
    }(ThreeObject3d));
    ThreeCamera.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeCamera, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    ThreeCamera.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeCamera, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeCamera, decorators: [{
                type: i0.Directive
            }] });

    var PrimitiveDirective = /** @class */ (function (_super) {
        __extends(PrimitiveDirective, _super);
        function PrimitiveDirective(animationStore, ngZone, object3dController, canvasStore, parentObjectDirective) {
            var _this = _super.call(this, animationStore, ngZone) || this;
            _this.animationStore = animationStore;
            _this.ngZone = ngZone;
            _this.object3dController = object3dController;
            _this.canvasStore = canvasStore;
            _this.parentObjectDirective = parentObjectDirective;
            _this.ready = new i0.EventEmitter();
            return _this;
        }
        Object.defineProperty(PrimitiveDirective.prototype, "object", {
            get: function () {
                return this._object;
            },
            set: function (value) {
                if (value == null) {
                    console.error('[object] is required');
                }
                this._object = value;
                if (value) {
                    this.ready.emit(value);
                    this.participate(value);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PrimitiveDirective.prototype, "object3d", {
            get: function () {
                return this._object;
            },
            enumerable: false,
            configurable: true
        });
        PrimitiveDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                _this.appendToParent();
            });
        };
        PrimitiveDirective.prototype.ngOnDestroy = function () {
            var _this = this;
            _super.prototype.ngOnDestroy.call(this);
            this.ngZone.runOutsideAngular(function () {
                if (_this.object3d) {
                    _this.remove();
                }
            });
        };
        PrimitiveDirective.prototype.appendToParent = function () {
            if (this.object3d && this.object3d instanceof THREE.Object3D) {
                if (this.object3dController.appendTo) {
                    this.object3dController.appendTo.add(this.object3d);
                    return;
                }
                var scene = this.canvasStore.getImperativeState().scene;
                if (this.object3dController.appendMode === 'root') {
                    if (scene) {
                        scene.add(this.object3d);
                    }
                    return;
                }
                if (this.object3dController.appendMode === 'immediate') {
                    if (this.parentObjectDirective) {
                        this.parentObjectDirective.object3d.add(this.object3d);
                    }
                    else {
                        if (scene) {
                            scene.add(this.object3d);
                        }
                    }
                }
            }
        };
        PrimitiveDirective.prototype.remove = function () {
            if (this.object3d instanceof THREE.Object3D) {
                if (this.object3dController.appendTo) {
                    this.object3dController.appendTo.remove(this.object3d);
                }
                else if (this.parentObjectDirective &&
                    this.object3dController.appendMode === 'immediate') {
                    this.parentObjectDirective.object3d.remove(this.object3d);
                }
                else {
                    var scene = this.canvasStore.getImperativeState().scene;
                    if (scene) {
                        scene.remove(this.object3d);
                    }
                }
                this.object3d.clear();
            }
        };
        return PrimitiveDirective;
    }(AnimationLoopParticipant));
    PrimitiveDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: PrimitiveDirective, deps: [{ token: AnimationStore }, { token: i0__namespace.NgZone }, { token: OBJECT_3D_WATCHED_CONTROLLER }, { token: CanvasStore }, { token: ThreeObject3d, optional: true, skipSelf: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    PrimitiveDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: PrimitiveDirective, selector: "ngt-primitive", inputs: { object: "object" }, outputs: { ready: "ready" }, providers: [
            {
                provide: ThreeObject3d,
                useExisting: PrimitiveDirective,
            },
            OBJECT_3D_CONTROLLER_PROVIDER,
        ], exportAs: ["ngtPrimitive"], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: PrimitiveDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'ngt-primitive',
                        exportAs: 'ngtPrimitive',
                        providers: [
                            {
                                provide: ThreeObject3d,
                                useExisting: PrimitiveDirective,
                            },
                            OBJECT_3D_CONTROLLER_PROVIDER,
                        ],
                    }]
            }], ctorParameters: function () {
            return [{ type: AnimationStore }, { type: i0__namespace.NgZone }, { type: Object3dControllerDirective, decorators: [{
                            type: i0.Inject,
                            args: [OBJECT_3D_WATCHED_CONTROLLER]
                        }] }, { type: CanvasStore }, { type: ThreeObject3d, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.SkipSelf
                        }] }];
        }, propDecorators: { ready: [{
                    type: i0.Output
                }], object: [{
                    type: i0.Input
                }] } });

    var ThreePrimitiveModule = /** @class */ (function () {
        function ThreePrimitiveModule() {
        }
        return ThreePrimitiveModule;
    }());
    ThreePrimitiveModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreePrimitiveModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ThreePrimitiveModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreePrimitiveModule, declarations: [PrimitiveDirective], exports: [PrimitiveDirective] });
    ThreePrimitiveModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreePrimitiveModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreePrimitiveModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [PrimitiveDirective],
                        exports: [PrimitiveDirective],
                    }]
            }] });

    var MathPipe = /** @class */ (function () {
        function MathPipe() {
        }
        MathPipe.prototype.transform = function (value, keyOfMath) {
            var params = Array.isArray(value) ? value : [value];
            return Math[keyOfMath].apply(Math, __spreadArray([], __read(params)));
        };
        return MathPipe;
    }());
    MathPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: MathPipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    MathPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: MathPipe, name: "math" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: MathPipe, decorators: [{
                type: i0.Pipe,
                args: [{
                        name: 'math',
                        pure: true,
                    }]
            }] });

    var ThreeMathPipeModule = /** @class */ (function () {
        function ThreeMathPipeModule() {
        }
        return ThreeMathPipeModule;
    }());
    ThreeMathPipeModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMathPipeModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ThreeMathPipeModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMathPipeModule, declarations: [MathPipe], exports: [MathPipe] });
    ThreeMathPipeModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMathPipeModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMathPipeModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [MathPipe],
                        exports: [MathPipe],
                    }]
            }] });

    var MathConstantPipe = /** @class */ (function () {
        function MathConstantPipe() {
        }
        MathConstantPipe.prototype.transform = function (value, keyOfMathConst) {
            if (keyOfMathConst === 'random') {
                return Math.random();
            }
            return value * Math[keyOfMathConst];
        };
        return MathConstantPipe;
    }());
    MathConstantPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: MathConstantPipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    MathConstantPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: MathConstantPipe, name: "mathConst" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: MathConstantPipe, decorators: [{
                type: i0.Pipe,
                args: [{
                        name: 'mathConst',
                        pure: true,
                    }]
            }] });

    var ThreeMathConstantPipeModule = /** @class */ (function () {
        function ThreeMathConstantPipeModule() {
        }
        return ThreeMathConstantPipeModule;
    }());
    ThreeMathConstantPipeModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMathConstantPipeModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ThreeMathConstantPipeModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMathConstantPipeModule, declarations: [MathConstantPipe], exports: [MathConstantPipe] });
    ThreeMathConstantPipeModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMathConstantPipeModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeMathConstantPipeModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [MathConstantPipe],
                        exports: [MathConstantPipe],
                    }]
            }] });

    var ColorPipe = /** @class */ (function () {
        function ColorPipe() {
        }
        /**
         * ConstructorParameters<typeof THREE.Color> has a limitation on THREE.Color constructor overloads
         */
        ColorPipe.prototype.transform = function (args) {
            var _a;
            return new ((_a = THREE__namespace.Color).bind.apply(_a, __spreadArray([void 0], __read(args))))();
        };
        return ColorPipe;
    }());
    ColorPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ColorPipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    ColorPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ColorPipe, name: "color" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ColorPipe, decorators: [{
                type: i0.Pipe,
                args: [{
                        name: 'color',
                        pure: true,
                    }]
            }] });

    var ThreeColorPipeModule = /** @class */ (function () {
        function ThreeColorPipeModule() {
        }
        return ThreeColorPipeModule;
    }());
    ThreeColorPipeModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeColorPipeModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ThreeColorPipeModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeColorPipeModule, declarations: [ColorPipe], exports: [ColorPipe] });
    ThreeColorPipeModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeColorPipeModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeColorPipeModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [ColorPipe],
                        exports: [ColorPipe],
                    }]
            }] });

    var FogPipe = /** @class */ (function () {
        function FogPipe() {
        }
        FogPipe.prototype.transform = function (args) {
            var _a;
            return new ((_a = THREE__namespace.Fog).bind.apply(_a, __spreadArray([void 0], __read(args))))();
        };
        return FogPipe;
    }());
    FogPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: FogPipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    FogPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: FogPipe, name: "fog" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: FogPipe, decorators: [{
                type: i0.Pipe,
                args: [{
                        name: 'fog',
                        pure: true,
                    }]
            }] });

    var ThreeFogPipeModule = /** @class */ (function () {
        function ThreeFogPipeModule() {
        }
        return ThreeFogPipeModule;
    }());
    ThreeFogPipeModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeFogPipeModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ThreeFogPipeModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeFogPipeModule, declarations: [FogPipe], exports: [FogPipe] });
    ThreeFogPipeModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeFogPipeModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeFogPipeModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [FogPipe],
                        exports: [FogPipe],
                    }]
            }] });

    var MAX_VALUE = 0x10000;
    var RepeatDirective = /** @class */ (function () {
        function RepeatDirective(viewContainer, templateRef) {
            this.viewContainer = viewContainer;
            this.templateRef = templateRef;
        }
        Object.defineProperty(RepeatDirective.prototype, "repeatOf", {
            set: function (count) {
                var safeCount = Math.floor(Math.max(0, Math.min(count, MAX_VALUE)));
                var length = this.viewContainer.length;
                if (safeCount < length) {
                    this.removeContainers(length - safeCount);
                }
                else {
                    this.addContainers(length, safeCount);
                }
            },
            enumerable: false,
            configurable: true
        });
        RepeatDirective.prototype.addContainers = function (length, count) {
            for (var index = length; index < count; index++) {
                this.viewContainer.createEmbeddedView(this.templateRef, {
                    $implicit: index,
                    isFirst: index === length,
                    isLast: index === count - 1,
                    isOdd: !(index % 2),
                    isEven: !!(index % 2),
                });
            }
        };
        RepeatDirective.prototype.removeContainers = function (amount) {
            for (var index = 0; index < amount; index++) {
                this.viewContainer.remove();
            }
        };
        RepeatDirective.ngTemplateContextGuard = function (dir, ctx) {
            return true;
        };
        return RepeatDirective;
    }());
    RepeatDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: RepeatDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    RepeatDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: RepeatDirective, selector: "[repeat][repeatOf]", inputs: { repeatOf: "repeatOf" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: RepeatDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[repeat][repeatOf]',
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ViewContainerRef, decorators: [{
                            type: i0.Inject,
                            args: [i0.ViewContainerRef]
                        }] }, { type: i0__namespace.TemplateRef, decorators: [{
                            type: i0.Inject,
                            args: [i0.TemplateRef]
                        }] }];
        }, propDecorators: { repeatOf: [{
                    type: i0.Input
                }] } });

    var ThreeRepeatModule = /** @class */ (function () {
        function ThreeRepeatModule() {
        }
        return ThreeRepeatModule;
    }());
    ThreeRepeatModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeRepeatModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ThreeRepeatModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeRepeatModule, declarations: [RepeatDirective], exports: [RepeatDirective] });
    ThreeRepeatModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeRepeatModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ThreeRepeatModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [RepeatDirective],
                        exports: [RepeatDirective],
                    }]
            }] });

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AnimationLoopParticipant = AnimationLoopParticipant;
    exports.AnimationStore = AnimationStore;
    exports.CanvasComponent = CanvasComponent;
    exports.CanvasStore = CanvasStore;
    exports.ColorPipe = ColorPipe;
    exports.Controller = Controller;
    exports.DestroyedService = DestroyedService;
    exports.EventsStore = EventsStore;
    exports.FogPipe = FogPipe;
    exports.InstancesStore = InstancesStore;
    exports.LoaderService = LoaderService;
    exports.LoopService = LoopService;
    exports.MathConstantPipe = MathConstantPipe;
    exports.MathPipe = MathPipe;
    exports.OBJECT_3D_CONTROLLER_PROVIDER = OBJECT_3D_CONTROLLER_PROVIDER;
    exports.OBJECT_3D_WATCHED_CONTROLLER = OBJECT_3D_WATCHED_CONTROLLER;
    exports.Object3dControllerDirective = Object3dControllerDirective;
    exports.PrimitiveDirective = PrimitiveDirective;
    exports.RepeatDirective = RepeatDirective;
    exports.ThreeAttribute = ThreeAttribute;
    exports.ThreeBufferGeometry = ThreeBufferGeometry;
    exports.ThreeCamera = ThreeCamera;
    exports.ThreeColorPipeModule = ThreeColorPipeModule;
    exports.ThreeCoreModule = ThreeCoreModule;
    exports.ThreeCurve = ThreeCurve;
    exports.ThreeFogPipeModule = ThreeFogPipeModule;
    exports.ThreeHelper = ThreeHelper;
    exports.ThreeLight = ThreeLight;
    exports.ThreeLine = ThreeLine;
    exports.ThreeMaterial = ThreeMaterial;
    exports.ThreeMathConstantPipeModule = ThreeMathConstantPipeModule;
    exports.ThreeMathPipeModule = ThreeMathPipeModule;
    exports.ThreeMesh = ThreeMesh;
    exports.ThreeObject3d = ThreeObject3d;
    exports.ThreeObject3dMaterialGeometry = ThreeObject3dMaterialGeometry;
    exports.ThreePrimitiveModule = ThreePrimitiveModule;
    exports.ThreeRepeatModule = ThreeRepeatModule;
    exports.ThreeSprite = ThreeSprite;
    exports.ThreeTexture = ThreeTexture;
    exports.applyProps = applyProps;
    exports.isOrthographicCamera = isOrthographicCamera;
    exports.object3dWatchedControllerFactory = object3dWatchedControllerFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=angular-three-core.umd.js.map
