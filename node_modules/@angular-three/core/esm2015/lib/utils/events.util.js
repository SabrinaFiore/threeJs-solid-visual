import { Vector3 } from 'three';
import { makeId } from './make-id.util';
/**
 * From r3f https://github.com/pmndrs/react-three-fiber/blob/master/packages/fiber/src/core/events.ts
 */
export function createEvents(canvasStateGetter, eventsStateGetter, instancesStateGetter) {
    const temp = new Vector3();
    /** Sets up defaultRaycaster */
    function prepareRay(event) {
        var _a, _b;
        const { raycaster, mouse, camera, clock, renderer, scene, internal: { size, viewport }, } = canvasStateGetter();
        const delta = clock.getDelta();
        if (raycaster && camera && renderer && scene) {
            const { offsetX, offsetY } = (_b = (_a = raycaster.computeOffsets) === null || _a === void 0 ? void 0 : _a.call(raycaster, event, {
                camera,
                clock,
                size,
                viewport,
                renderer,
                scene,
                delta,
                mouse,
            })) !== null && _b !== void 0 ? _b : event;
            const { width, height } = size;
            mouse.set((offsetX / width) * 2 - 1, -(offsetY / height) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
        }
    }
    /** Calculates delta */
    function calculateDistance(event) {
        const { internal: { initialClick }, } = eventsStateGetter();
        const dx = event.offsetX - initialClick[0];
        const dy = event.offsetY - initialClick[1];
        return Math.round(Math.sqrt(dx * dx + dy * dy));
    }
    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */
    function filterPointerEvents(objects) {
        return objects.filter((obj) => ['move', 'over', 'enter', 'out', 'leave'].some((name) => {
            var _a, _b;
            return (_b = (_a = obj.__ngt) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b[('pointer' + name)];
        }));
    }
    function intersect(filter) {
        var _a;
        const { raycaster } = canvasStateGetter();
        const { objects } = instancesStateGetter();
        // Skip event handling when noEvents is set
        if (!raycaster || (raycaster && !raycaster.enabled))
            return [];
        const seen = new Set();
        const intersections = [];
        // Allow callers to eliminate event objects
        const eventsObjects = filter
            ? filter(Object.values(objects))
            : Object.values(objects);
        // Intersect known handler objects and filter against duplicates
        const intersects = raycaster
            .intersectObjects(eventsObjects, true)
            .filter((item) => {
            const id = makeId(item);
            if (seen.has(id))
                return false;
            seen.add(id);
            return true;
        });
        // https://github.com/mrdoob/three.js/issues/16031
        // Allow custom userland intersect sort order
        // if (raycaster.filter) intersects = raycaster.filter(intersects, state);
        for (const intersect of intersects) {
            let eventObject = intersect.object;
            // Bubble event up
            while (eventObject) {
                const handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;
                if (handlers)
                    intersections.push(Object.assign(Object.assign({}, intersect), { eventObject }));
                eventObject = eventObject.parent;
            }
        }
        return intersections;
    }
    /**  Creates filtered intersects and returns an array of positive hits */
    function patchIntersects(intersections, event) {
        const { internal: { capturedMap }, } = eventsStateGetter();
        // If the interaction is captured take that into account, the captured event has to be part of the intersects
        if ('pointerId' in event && capturedMap.has(event.pointerId)) {
            intersections.push(...capturedMap.get(event.pointerId).values());
        }
        return intersections;
    }
    /**  Handles intersections by forwarding them to handlers */
    function handleIntersects(intersections, event, callback) {
        const { raycaster, mouse, camera } = canvasStateGetter();
        const { internal: eventsInternal } = eventsStateGetter();
        // If anything has been found, forward it to the event listeners
        if (intersections.length && camera) {
            const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);
            const delta = event.type === 'click' ? calculateDistance(event) : 0;
            const releasePointerCapture = (id) => event.target.releasePointerCapture(id);
            const localState = { stopped: false };
            for (const hit of intersections) {
                const hasPointerCapture = (id) => { var _a, _b; return (_b = (_a = eventsInternal.capturedMap.get(id)) === null || _a === void 0 ? void 0 : _a.has(hit.eventObject)) !== null && _b !== void 0 ? _b : false; };
                const setPointerCapture = (id) => {
                    if (eventsInternal.capturedMap.has(id)) {
                        // if the pointerId was previously captured, we add the hit to the
                        // event capturedMap.
                        eventsInternal.capturedMap.get(id).set(hit.eventObject, hit);
                    }
                    else {
                        // if the pointerId was not previously captured, we create a map
                        // containing the hitObject, and the hit. hitObject is used for
                        // faster access.
                        eventsInternal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));
                    }
                    // Call the original event now
                    event.target.setPointerCapture(id);
                };
                // Add native event props
                const extractEventProps = {};
                for (const prop in Object.getPrototypeOf(event)) {
                    // noinspection JSUnfilteredForInLoop
                    const property = event[prop];
                    // Only copy over atomics, leave functions alone as these should be
                    // called as event.nativeEvent.fn()
                    if (typeof property !== 'function') {
                        // noinspection JSUnfilteredForInLoop
                        extractEventProps[prop] = property;
                    }
                }
                const raycastEvent = Object.assign(Object.assign(Object.assign({}, hit), extractEventProps), { spaceX: mouse.x, spaceY: mouse.y, intersections, stopped: localState.stopped, delta,
                    unprojectedPoint, ray: raycaster ? raycaster.ray : null, camera, 
                    // Hijack stopPropagation, which just sets a flag
                    stopPropagation: () => {
                        // https://github.com/pmndrs/react-three-fiber/issues/596
                        // Events are not allowed to stop propagation if the pointer has been captured
                        const capturesForPointer = 'pointerId' in event &&
                            eventsInternal.capturedMap.get(event.pointerId);
                        // We only authorize stopPropagation...
                        if (
                        // ...if this pointer hasn't been captured
                        !capturesForPointer ||
                            // ... or if the hit object is capturing the pointer
                            capturesForPointer.has(hit.eventObject)) {
                            raycastEvent.stopped = localState.stopped = true;
                            // Propagation is stopped, remove all other hover records
                            // An event handler is only allowed to flush other handlers if it is hovered itself
                            if (eventsInternal.hovered.size &&
                                Array.from(eventsInternal.hovered.values()).find((i) => i.eventObject === hit.eventObject)) {
                                // Objects cannot flush out higher up objects that have already caught the event
                                const higher = intersections.slice(0, intersections.indexOf(hit));
                                cancelPointer([...higher, hit]);
                            }
                        }
                    }, target: Object.assign(Object.assign({}, event.target), { setPointerCapture,
                        releasePointerCapture,
                        hasPointerCapture }), currentTarget: Object.assign(Object.assign({}, event.currentTarget), { setPointerCapture,
                        releasePointerCapture,
                        hasPointerCapture }), sourceEvent: event, nativeEvent: event });
                // Call subscribers
                callback(raycastEvent);
                // Event bubbling may be interrupted by stopPropagation
                if (localState.stopped)
                    break;
            }
        }
        return intersections;
    }
    function cancelPointer(hits) {
        const { internal } = eventsStateGetter();
        Array.from(internal.hovered.values()).forEach((hoveredObj) => {
            var _a, _b, _c;
            // When no objects were hit or the the hovered object wasn't found underneath the cursor
            // we call onPointerOut and delete the object from the hovered-elements map
            if (!hits.length ||
                !hits.find((hit) => hit.object === hoveredObj.object && hit.index === hoveredObj.index)) {
                const eventObject = hoveredObj.eventObject;
                const handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;
                internal.hovered.delete(makeId(hoveredObj));
                if (handlers) {
                    // Clear out intersects, they are outdated by now
                    const data = Object.assign(Object.assign({}, hoveredObj), { intersections: hits || [] });
                    (_b = handlers.pointerout) === null || _b === void 0 ? void 0 : _b.call(handlers, data);
                    (_c = handlers.pointerleave) === null || _c === void 0 ? void 0 : _c.call(handlers, data);
                }
            }
        });
    }
    const handlePointer = (name) => {
        // Deal with cancellation
        switch (name) {
            case 'pointerleave':
            case 'pointercancel':
                return () => cancelPointer([]);
            case 'lostpointercapture':
                return (event) => {
                    if ('pointerId' in event) {
                        // this will be a problem if one target releases the pointerId
                        // and another one is still keeping it, as the line below
                        // indifferently deletes all capturing references.
                        const { internal: { capturedMap }, } = eventsStateGetter();
                        capturedMap.delete(event.pointerId);
                    }
                };
        }
        // Any other pointer goes here ...
        return (event) => {
            const { internal } = eventsStateGetter();
            const { objects } = instancesStateGetter();
            prepareRay(event);
            // Get fresh intersects
            const isPointerMove = name === 'pointermove';
            const filter = isPointerMove ? filterPointerEvents : undefined;
            const hits = patchIntersects(intersect(filter), event);
            // Take care of unhover
            if (isPointerMove)
                cancelPointer(hits);
            handleIntersects(hits, event, (data) => {
                var _a, _b, _c, _d;
                const eventObject = data.eventObject;
                const handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;
                // Check presence of handlers
                if (!handlers)
                    return;
                if (isPointerMove) {
                    // Move event ...
                    if (handlers.pointerover ||
                        handlers.pointerenter ||
                        handlers.pointerout ||
                        handlers.pointerleave) {
                        // When enter or out is present take care of hover-state
                        const id = makeId(data);
                        const hoveredItem = internal.hovered.get(id);
                        if (!hoveredItem) {
                            // If the object wasn't previously hovered, book it and call its handler
                            internal.hovered.set(id, data);
                            (_b = handlers.pointerover) === null || _b === void 0 ? void 0 : _b.call(handlers, data);
                            (_c = handlers.pointerenter) === null || _c === void 0 ? void 0 : _c.call(handlers, data);
                        }
                        else if (hoveredItem.stopped) {
                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed
                            data.stopPropagation();
                        }
                    }
                    // Call mouse move
                    (_d = handlers.pointermove) === null || _d === void 0 ? void 0 : _d.call(handlers, data);
                }
                else {
                    // All other events ...
                    const handler = handlers === null || handlers === void 0 ? void 0 : handlers[name];
                    if (handler) {
                        // Forward all events back to their respective handlers with the exception of click events,
                        // which must use the initial target
                        if ((name !== 'click' &&
                            name !== 'contextmenu' &&
                            name !== 'dblclick') ||
                            internal.initialHits.includes(eventObject)) {
                            handler(data);
                            pointerMissed(event, Object.values(objects).filter((object) => object !== eventObject));
                        }
                    }
                }
            });
            // Save initial coordinates on pointer-down
            if (name === 'pointerdown') {
                internal.initialClick = [event.offsetX, event.offsetY];
                internal.initialHits = hits.map((hit) => hit.eventObject);
            }
            // If a click yields no results, pass it back to the user as a miss
            if ((name === 'click' || name === 'contextmenu' || name === 'dblclick') &&
                !hits.length) {
                if (calculateDistance(event) <= 2) {
                    pointerMissed(event, Object.values(objects));
                    // if (onPointerMissed) onPointerMissed();
                }
            }
        };
    };
    function pointerMissed(event, objects) {
        objects.forEach((object) => {
            var _a, _b, _c;
            return (_c = (_b = (_a = object.__ngt) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.pointermissed) === null || _c === void 0 ? void 0 : _c.call(_b, event);
        });
    }
    return { handlePointer };
}
//# sourceMappingURL=events.util.js.map