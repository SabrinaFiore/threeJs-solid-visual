import { Injectable } from '@angular/core';
import { combineLatest } from 'rxjs';
import { filter, mapTo, tap, withLatestFrom } from 'rxjs/operators';
import { ACESFilmicToneMapping, Camera, Clock, OrthographicCamera, PCFSoftShadowMap, PerspectiveCamera, Raycaster, Scene, sRGBEncoding, Vector2, Vector3, WebGLRenderer, } from 'three';
import { applyProps } from '../utils';
import { ImperativeComponentStore } from './imperative-component-store.abstract';
import * as i0 from "@angular/core";
const position = new Vector3();
const defaultTarget = new Vector3();
export const isOrthographicCamera = (def) => def && def.isOrthographicCamera;
export class CanvasStore extends ImperativeComponentStore {
    constructor() {
        super({
            isOrthographic: false,
            isLinear: false,
            shadows: false,
            mouse: new Vector2(),
            clock: new Clock(),
            internal: {
                active: false,
                size: { width: 0, height: 0 },
                dpr: 1,
                viewport: {
                    initialDpr: 1,
                    dpr: 1,
                    width: 0,
                    height: 0,
                    aspect: 0,
                    distance: 0,
                    factor: 0,
                    getCurrentViewport: (camera = this.getImperativeState().camera, target = defaultTarget, size = this.getImperativeState().internal.size) => {
                        const { width, height } = size;
                        const aspect = width / height;
                        const distance = camera
                            .getWorldPosition(position)
                            .distanceTo(target);
                        if (isOrthographicCamera(camera)) {
                            return {
                                width: width / camera.zoom,
                                height: height / camera.zoom,
                                factor: 1,
                                distance,
                                aspect,
                            };
                        }
                        const fov = (camera.fov * Math.PI) / 180; // convert vertical fov to radians
                        const h = 2 * Math.tan(fov / 2) * distance; // visible height
                        const w = h * (width / height);
                        return {
                            width: w,
                            height: h,
                            factor: width / w,
                            distance,
                            aspect,
                        };
                    },
                },
            },
        });
        this.renderer$ = this.select((s) => s.renderer);
        this.camera$ = this.select((s) => s.camera);
        this.scene$ = this.select((s) => s.scene);
        this.raycaster$ = this.select((s) => s.raycaster);
        this.isOrthographic$ = this.select((s) => s.isOrthographic);
        this.isLinear$ = this.select((s) => s.isLinear);
        this.shadows$ = this.select((s) => s.shadows);
        this.active$ = this.select((s) => s.internal.active);
        this.canvasInternal$ = this.select((s) => s.internal);
        this.setIsOrthographic = this.updater((state, isOrthographic) => (Object.assign(Object.assign({}, state), { isOrthographic })));
        this.setIsLinear = this.updater((state, isLinear) => (Object.assign(Object.assign({}, state), { isLinear })));
        this.setShadows = this.updater((state, shadows) => (Object.assign(Object.assign({}, state), { shadows })));
        this.setSize = this.updater((state, size) => (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { size }) })));
        this.setDpr = this.updater((state, dpr) => (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { dpr }) })));
        this.setViewport = this.updater((state) => (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { viewport: Object.assign(Object.assign(Object.assign({}, state.internal.viewport), state.internal.viewport.getCurrentViewport(state.camera, defaultTarget, state.internal.size)), { dpr: state.internal.dpr }) }) })));
        this.setActive = this.updater((state, active) => (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { active }) })));
        this.initRendererEffect = this.effect((canvas$) => {
            return canvas$.pipe(withLatestFrom(this.canvasInternal$, this.isLinear$, this.shadows$), tap(([canvas, { size, dpr }, isLinear, shadows]) => {
                const renderer = new WebGLRenderer({
                    canvas,
                    antialias: true,
                    powerPreference: 'high-performance',
                    alpha: true,
                });
                if (shadows) {
                    renderer.shadowMap.enabled = true;
                    if (typeof shadows === 'object')
                        Object.assign(renderer.shadowMap, shadows);
                    else
                        renderer.shadowMap.type = PCFSoftShadowMap;
                }
                if (!isLinear) {
                    renderer.toneMapping = ACESFilmicToneMapping;
                    renderer.outputEncoding = sRGBEncoding;
                }
                renderer.setClearAlpha(0);
                renderer.setPixelRatio(dpr);
                renderer.setSize(size.width, size.height);
                this.patchState({ renderer });
            }));
        });
        this.initSceneEffect = this.effect((sceneOptions$) => sceneOptions$.pipe(tap((sceneOptions) => {
            const scene = new Scene();
            applyProps(scene, sceneOptions);
            this.patchState({ scene });
        })));
        this.initCameraEffect = this.effect((cameraOptions$) => cameraOptions$.pipe(withLatestFrom(this.isOrthographic$, this.canvasInternal$), tap(([cameraOptions, isOrthographic, { size }]) => {
            var _a;
            const isCamera = cameraOptions instanceof Camera;
            let camera;
            if (isCamera) {
                camera = cameraOptions;
            }
            else {
                if (isOrthographic) {
                    camera = new OrthographicCamera(0, 0, 0, 0, 0.1, 1000);
                    camera.zoom = 100;
                }
                else {
                    camera = new PerspectiveCamera(75, (_a = size.width / size.height) !== null && _a !== void 0 ? _a : 0, 0.1, 1000);
                }
                camera.position.z = 5;
                applyProps(camera, cameraOptions);
                // Update projection matrix after applying props
                camera.updateProjectionMatrix();
            }
            // look at center by default
            camera.lookAt(0, 0, 0);
            this.patchState({ camera });
            this.setViewport();
        })));
        this.initRaycasterEffect = this.effect((raycasterOptions$) => raycasterOptions$.pipe(tap((raycasterOptions) => {
            const raycaster = new Raycaster();
            raycaster.enabled = true;
            applyProps(raycaster, raycasterOptions);
            this.patchState({ raycaster });
        })));
        this.windowResizeEffect = this.effect((params$) => params$.pipe(withLatestFrom(this.renderer$, this.camera$), tap(([{ dpr, size }, renderer, camera]) => {
            if (camera.type === 'PerspectiveCamera') {
                camera.aspect = size.width / size.height;
            }
            else {
                camera.left = size.width / -2;
                camera.right = size.width / 2;
                camera.top = size.height / 2;
                camera.bottom = size.height / -2;
            }
            camera.updateProjectionMatrix();
            camera.updateMatrixWorld();
            renderer.setPixelRatio(dpr);
            renderer.setSize(size.width, size.height);
            this.setSize(size);
            this.setDpr(dpr);
            this.setViewport();
        })));
        this.setActive(combineLatest([
            this.renderer$,
            this.camera$,
            this.scene$,
            this.raycaster$,
        ]).pipe(filter((coreObjects) => coreObjects.every(Boolean)), mapTo(true)));
    }
    ngOnDestroy() {
        const { renderer } = this.getImperativeState();
        if (renderer) {
            renderer.renderLists.dispose();
            renderer.forceContextLoss();
        }
        super.ngOnDestroy();
    }
}
CanvasStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CanvasStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });
//# sourceMappingURL=canvas.store.js.map