import { __rest } from "tslib";
import { Injectable } from '@angular/core';
import { isObservable } from 'rxjs';
import { filter, skip, tap, withLatestFrom } from 'rxjs/operators';
import { makeId } from '../utils';
import { ImperativeComponentStore } from './imperative-component-store.abstract';
import * as i0 from "@angular/core";
export class AnimationStore extends ImperativeComponentStore {
    constructor() {
        super({
            animations: {},
            objectSubscriptions: [],
            animationCallbacks: [],
            hasPriority: false,
        });
        this.animationsChangedEffect = this.effect((animations$) => animations$.pipe(tap((animations) => {
            const animationCallbacks = Object.values(animations);
            const hasPriority = animationCallbacks.some(({ priority }) => !!priority);
            this.patchState({ animationCallbacks, hasPriority });
        })));
        this.unregisterAnimationEffect = this.effect((uuid$) => uuid$.pipe(withLatestFrom(this.state$), tap(([uuid, { animations, objectSubscriptions }]) => {
            const subscription = objectSubscriptions.find(([objectUuid]) => objectUuid === uuid);
            if (subscription) {
                subscription[1].unsubscribe();
            }
            const _a = animations, _b = uuid, _ = _a[_b], updatedAnimations = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            this.patchState({
                animations: updatedAnimations,
                objectSubscriptions: objectSubscriptions.filter(([objectUuid]) => objectUuid !== uuid),
            });
        })));
        this.clearEffect = this.effect((trigger$) => trigger$.pipe(tap(() => {
            this.patchState((state) => {
                state.objectSubscriptions.forEach(([, subscription]) => subscription.unsubscribe());
                return { animations: {}, objectSubscriptions: [] };
            });
        })));
        this.animationsChangedEffect(this.select((s) => s.animations).pipe(skip(1)));
    }
    registerAnimation(objOrObsOrCallback, callbackOrPriority, priority = 0) {
        if (objOrObsOrCallback === undefined)
            return;
        if (typeof objOrObsOrCallback === 'function') {
            const id = makeId();
            this.patchState((state) => (Object.assign(Object.assign({}, state), { animations: Object.assign(Object.assign({}, state.animations), { [id]: {
                        obj: null,
                        callback: objOrObsOrCallback,
                        priority: callbackOrPriority || 0,
                    } }) })));
            return () => {
                this.unregisterAnimationEffect(id);
            };
        }
        if (isObservable(objOrObsOrCallback)) {
            let id = '';
            const subscription = objOrObsOrCallback
                .pipe(filter((obj) => !!obj))
                .subscribe((obj) => {
                this.patchState((state) => {
                    var _a;
                    const objectSubscriptions = state.objectSubscriptions;
                    if ((_a = objectSubscriptions[objectSubscriptions.length - 1]) === null || _a === void 0 ? void 0 : _a[0]) {
                        objectSubscriptions[objectSubscriptions.length - 1][0] = obj.uuid;
                    }
                    id = obj.uuid;
                    return {
                        animations: Object.assign(Object.assign({}, state.animations), { [id]: {
                                obj,
                                callback: callbackOrPriority,
                                priority,
                            } }),
                        objectSubscriptions,
                    };
                });
            });
            this.patchState((state) => ({
                objectSubscriptions: [
                    ...state.objectSubscriptions,
                    [null, subscription],
                ],
            }));
            return () => {
                this.unregisterAnimationEffect(id);
            };
        }
        const uuid = objOrObsOrCallback.uuid;
        this.patchState((state) => ({
            animations: Object.assign(Object.assign({}, state.animations), { [uuid]: {
                    obj: objOrObsOrCallback,
                    callback: callbackOrPriority,
                    priority,
                } }),
        }));
        return () => {
            this.unregisterAnimationEffect(uuid);
        };
    }
    ngOnDestroy() {
        this.clearEffect();
        super.ngOnDestroy();
    }
}
AnimationStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: AnimationStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
AnimationStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: AnimationStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: AnimationStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });
//# sourceMappingURL=animation.store.js.map