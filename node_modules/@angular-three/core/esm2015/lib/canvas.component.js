import { DOCUMENT } from '@angular/common';
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostBinding, Inject, Input, NgZone, Output, Self, ViewChild, } from '@angular/core';
import { asapScheduler, fromEvent } from 'rxjs';
import { observeOn, takeUntil } from 'rxjs/operators';
import { DestroyedService, LoopService } from './services';
import { AnimationStore, CanvasStore, EventsStore, InstancesStore, } from './stores';
import * as i0 from "@angular/core";
import * as i1 from "./stores";
import * as i2 from "./services";
export class CanvasComponent {
    constructor(canvasStore, animationStore, eventsStore, loopService, ngZone, hostElement, document, destroyed) {
        this.canvasStore = canvasStore;
        this.animationStore = animationStore;
        this.eventsStore = eventsStore;
        this.loopService = loopService;
        this.ngZone = ngZone;
        this.hostElement = hostElement;
        this.document = document;
        this.destroyed = destroyed;
        this.hostClass = true;
        this.raycaster = {};
        this.created = new EventEmitter();
    }
    set orthographic(v) {
        this.canvasStore.setIsOrthographic(v);
    }
    set linear(v) {
        this.canvasStore.setIsLinear(v);
    }
    set shadows(v) {
        this.canvasStore.setShadows(v);
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            var _a;
            this.canvasStore.setSize({
                width: this.hostElement.nativeElement.clientWidth,
                height: this.hostElement.nativeElement.clientHeight,
            });
            this.canvasStore.setDpr(((_a = this.document.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) || 1);
            this.canvasStore.initRendererEffect(this.rendererCanvas.nativeElement);
            this.canvasStore.initSceneEffect(this.scene);
            this.canvasStore.initCameraEffect(this.camera);
            this.canvasStore.initRaycasterEffect(this.raycaster);
            this.initWindowResizeListener();
            this.initActiveListener();
        });
    }
    initWindowResizeListener() {
        var _a;
        if ((_a = this.document) === null || _a === void 0 ? void 0 : _a.defaultView) {
            fromEvent(this.document.defaultView, 'resize')
                .pipe(takeUntil(this.destroyed))
                .subscribe(() => {
                this.ngZone.runOutsideAngular(() => {
                    var _a;
                    this.canvasStore.windowResizeEffect({
                        size: {
                            width: this.hostElement.nativeElement.clientWidth,
                            height: this.hostElement.nativeElement.clientHeight,
                        },
                        dpr: ((_a = this.document.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) || 1,
                    });
                });
            });
        }
    }
    initActiveListener() {
        this.canvasStore.active$
            .pipe(takeUntil(this.destroyed), observeOn(asapScheduler))
            .subscribe((active) => {
            this.ngZone.runOutsideAngular(() => {
                if (active) {
                    const { renderer, camera, scene } = this.canvasStore.getImperativeState();
                    if (renderer && camera && scene) {
                        this.created.emit({ gl: renderer, camera, scene });
                        this.eventsStore.connectEffect(renderer.domElement);
                        this.loopService.start();
                    }
                }
            });
        });
    }
}
CanvasComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasComponent, deps: [{ token: i1.CanvasStore, self: true }, { token: i1.AnimationStore, self: true }, { token: i1.EventsStore, self: true }, { token: i2.LoopService, self: true }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: DOCUMENT }, { token: i2.DestroyedService }], target: i0.ɵɵFactoryTarget.Component });
CanvasComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: CanvasComponent, selector: "ngt-canvas", inputs: { orthographic: "orthographic", linear: "linear", shadows: "shadows", camera: "camera", scene: "scene", raycaster: "raycaster" }, outputs: { created: "created" }, host: { properties: { "class.ngt-canvas": "this.hostClass" } }, providers: [
        CanvasStore,
        EventsStore,
        InstancesStore,
        AnimationStore,
        LoopService,
        DestroyedService,
    ], viewQueries: [{ propertyName: "rendererCanvas", first: true, predicate: ["rendererCanvas"], descendants: true, static: true }], exportAs: ["ngtCanvas"], ngImport: i0, template: ` <canvas #rendererCanvas></canvas> `, isInline: true, styles: ["\n      :host {\n        display: block;\n        position: relative;\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n      }\n\n      :host canvas {\n        display: block;\n      }\n    "], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-canvas',
                    exportAs: 'ngtCanvas',
                    template: ` <canvas #rendererCanvas></canvas> `,
                    styles: [
                        `
      :host {
        display: block;
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      :host canvas {
        display: block;
      }
    `,
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        CanvasStore,
                        EventsStore,
                        InstancesStore,
                        AnimationStore,
                        LoopService,
                        DestroyedService,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1.CanvasStore, decorators: [{
                    type: Self
                }] }, { type: i1.AnimationStore, decorators: [{
                    type: Self
                }] }, { type: i1.EventsStore, decorators: [{
                    type: Self
                }] }, { type: i2.LoopService, decorators: [{
                    type: Self
                }] }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i2.DestroyedService }]; }, propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.ngt-canvas']
            }], orthographic: [{
                type: Input
            }], linear: [{
                type: Input
            }], shadows: [{
                type: Input
            }], camera: [{
                type: Input
            }], scene: [{
                type: Input
            }], raycaster: [{
                type: Input
            }], created: [{
                type: Output
            }], rendererCanvas: [{
                type: ViewChild,
                args: ['rendererCanvas', { static: true }]
            }] } });
//# sourceMappingURL=canvas.component.js.map