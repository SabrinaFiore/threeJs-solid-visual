import { Injectable } from '@angular/core';
import { Clock } from 'three';
import { AnimationStore, CanvasStore } from '../stores';
import * as i0 from "@angular/core";
import * as i1 from "../stores";
export class LoopService {
    // TODO: rethink limit 60fps
    // private readonly interval = 1 / 60; // 60fps;
    // private internalDelta = 0;
    constructor(canvasStore, animationStore) {
        this.canvasStore = canvasStore;
        this.animationStore = animationStore;
        this.loopClock = new Clock();
    }
    start() {
        const { renderer } = this.canvasStore.getImperativeState();
        if (renderer) {
            renderer.setAnimationLoop(() => {
                this.tick(this.loopClock.getDelta());
            });
        }
    }
    stop() {
        const { renderer } = this.canvasStore.getImperativeState();
        if (renderer) {
            renderer.setAnimationLoop(null);
        }
    }
    tick(delta) {
        // this.internalDelta += delta;
        //
        // if (this.internalDelta >= this.interval) {
        //   const {
        //     renderer,
        //     scene,
        //     camera,
        //     internal: { size, viewport },
        //     clock,
        //     mouse,
        //   } = this.canvasStore.getImperativeState();
        //   const { animationCallbacks, hasPriority } =
        //     this.animationStore.getImperativeState();
        //
        //   if (renderer && scene && camera) {
        //     if (hasPriority) {
        //       animationCallbacks.sort(
        //         ({ priority: a = 0 }, { priority: b = 0 }) => a - b
        //       );
        //     } else {
        //       renderer.render(scene, camera);
        //     }
        //
        //     const renderState = {
        //       clock,
        //       camera,
        //       scene,
        //       renderer,
        //       mouse,
        //       size,
        //       viewport,
        //       delta,
        //     };
        //     for (const animationCallback of animationCallbacks) {
        //       if (animationCallback.obj) {
        //         animationCallback.callback(animationCallback.obj, renderState);
        //       } else {
        //         animationCallback.callback(renderState);
        //       }
        //     }
        //   }
        //
        //   this.internalDelta = this.internalDelta % this.interval;
        // }
        const { renderer, scene, camera, internal: { size, viewport }, clock, mouse, } = this.canvasStore.getImperativeState();
        const { animationCallbacks, hasPriority } = this.animationStore.getImperativeState();
        if (renderer && scene && camera) {
            if (hasPriority) {
                animationCallbacks.sort(({ priority: a = 0 }, { priority: b = 0 }) => a - b);
            }
            else {
                renderer.render(scene, camera);
            }
            const renderState = {
                clock,
                camera,
                scene,
                renderer,
                mouse,
                size,
                viewport,
                delta,
            };
            for (const animationCallback of animationCallbacks) {
                if (animationCallback.obj) {
                    animationCallback.callback(animationCallback.obj, renderState);
                }
                else {
                    animationCallback.callback(renderState);
                }
            }
        }
    }
    ngOnDestroy() {
        this.stop();
    }
}
LoopService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: LoopService, deps: [{ token: i1.CanvasStore }, { token: i1.AnimationStore }], target: i0.ɵɵFactoryTarget.Injectable });
LoopService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: LoopService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: LoopService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.CanvasStore }, { type: i1.AnimationStore }]; } });
//# sourceMappingURL=loop.service.js.map