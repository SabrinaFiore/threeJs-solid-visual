import { Directive, Inject, NgZone, Optional, Output, SkipSelf, } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { filter, take } from 'rxjs/operators';
import { Color } from 'three';
import { Object3dControllerDirective } from '../controllers';
import { OBJECT_3D_WATCHED_CONTROLLER } from '../di';
import { AnimationStore, CanvasStore, EventsStore, InstancesStore, } from '../stores';
import { applyProps } from '../utils';
import { AnimationLoopParticipant } from './animation-loop-participant.abstract';
import * as i0 from "@angular/core";
import * as i1 from "../stores";
import * as i2 from "../controllers";
export class ThreeObject3d extends AnimationLoopParticipant {
    constructor(object3dController, canvasStore, instancesStore, eventsStore, animationStore, ngZone, parentObjectDirective) {
        super(animationStore, ngZone);
        this.object3dController = object3dController;
        this.canvasStore = canvasStore;
        this.instancesStore = instancesStore;
        this.eventsStore = eventsStore;
        this.animationStore = animationStore;
        this.ngZone = ngZone;
        this.parentObjectDirective = parentObjectDirective;
        this.$object3d = new BehaviorSubject(null);
        this.ready = this.object3d$.pipe(filter(Boolean));
        this.changesSubscription = object3dController.change$.subscribe(() => {
            if (this.object3d) {
                this.applyCustomProps();
            }
            if (this.inputChangeHandler) {
                this.inputChangeHandler();
            }
        });
    }
    get object3d$() {
        return this.$object3d.asObservable();
    }
    ngOnChanges() {
        if (this.object3d) {
            this.applyCustomProps();
        }
    }
    init() {
        this.ngZone.runOutsideAngular(() => {
            this.initObject();
            if (this.object3d) {
                this.applyCustomProps();
                applyProps(this.object3d, {
                    __ngt: {
                        canvasStateGetter: () => this.canvasStore.getImperativeState(),
                        eventsStateGetter: () => this.eventsStore.getImperativeState(),
                        handlers: this.applyEvents(),
                    },
                });
                this.instancesStore.saveObject(this.object3d);
                this.appendToParent();
                this.objectReady();
            }
        });
    }
    addToScene() {
        const { scene } = this.canvasStore.getImperativeState();
        if (scene) {
            scene.add(this.object3d);
        }
    }
    addToParent() {
        if (this.parentObjectDirective) {
            this.parentObjectDirective.object3d.add(this.object3d);
        }
        else {
            this.addToScene();
        }
    }
    remove() {
        if (this.object3dController.appendTo) {
            this.object3dController.appendTo.remove(this.object3d);
        }
        else if (this.parentObjectDirective &&
            this.object3dController.appendMode === 'immediate') {
            this.parentObjectDirective.object3d.remove(this.object3d);
        }
        else {
            const { scene } = this.canvasStore.getImperativeState();
            if (scene) {
                scene.remove(this.object3d);
            }
        }
        this.object3d.clear();
    }
    objectReady() {
        this.$object3d.next(this.object3d);
        this.participate(this.object3d);
    }
    applyCustomProps() {
        this.ngZone.runOutsideAngular(() => {
            const customProps = {
                castShadow: this.object3dController.castShadow,
                receiveShadow: this.object3dController.receiveShadow,
                visible: this.object3dController.visible,
                matrixAutoUpdate: this.object3dController.matrixAutoUpdate,
            };
            if (this.object3dController.name) {
                customProps['name'] = this.object3dController.name;
            }
            if (this.object3dController.position) {
                customProps['position'] = this.object3dController.position;
            }
            if (this.object3dController.rotation) {
                customProps['rotation'] = this.object3dController.rotation;
            }
            else if (this.object3dController.quaternion) {
                customProps['quaternion'] = this.object3dController.quaternion;
            }
            if (this.object3dController.scale) {
                customProps['scale'] = this.object3dController.scale;
            }
            if (this.object3dController.userData) {
                customProps['userData'] = this.object3dController.userData;
            }
            if (this.object3dController.color) {
                this.object3dController.color = Array.isArray(this.object3dController.color)
                    ? new Color(...this.object3dController.color)
                    : new Color(this.object3dController.color);
                if (!this.canvasStore.getImperativeState().isLinear) {
                    this.object3dController.color.convertSRGBToLinear();
                }
                customProps['color'] = this.object3dController.color;
            }
            if (this.object3dController.dispose) {
                customProps['dispose'] = this.object3dController.dispose;
            }
            this.object3dController.change$.pipe(take(1)).subscribe((changes) => {
                if (changes) {
                    for (const [inputName, inputChange] of Object.entries(changes)) {
                        if (!inputChange.isFirstChange() ||
                            [
                                'name',
                                'position',
                                'rotation',
                                'quaternion',
                                'scale',
                                'userData',
                                'color',
                                'dispose',
                                'castShadow',
                                'receiveShadow',
                                'visible',
                                'matrixAutoUpdate',
                            ].includes(inputName) // skip 12 common inputs
                        ) {
                            continue;
                        }
                        customProps[inputName] = inputChange.currentValue;
                    }
                }
            });
            applyProps(this.object3d, customProps);
            this.object3d.updateMatrix();
        });
    }
    applyEvents() {
        const handlers = {};
        [
            'click',
            'contextmenu',
            'dblclick',
            'pointerup',
            'pointerdown',
            'pointerover',
            'pointerout',
            'pointerenter',
            'pointerleave',
            'pointermove',
            'pointermissed',
            'pointercancel',
            'wheel',
        ].forEach((eventName) => {
            if (this.object3dController[eventName].observed) {
                handlers[eventName] = (event) => {
                    this.ngZone.run(() => {
                        this.object3dController[eventName].emit(event);
                    });
                };
            }
        });
        return handlers;
    }
    appendToParent() {
        if (this.object3dController.appendTo) {
            this.object3dController.appendTo.add(this.object3d);
            return;
        }
        if (this.object3dController.appendMode === 'root') {
            this.addToScene();
            return;
        }
        if (this.object3dController.appendMode === 'immediate') {
            this.addToParent();
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.changesSubscription) {
            this.changesSubscription.unsubscribe();
        }
        this.ngZone.runOutsideAngular(() => {
            if (this.object3d) {
                this.remove();
                this.instancesStore.removeObject(this.object3d.uuid);
                this.animationStore.unregisterAnimationEffect(this.object3d.uuid);
            }
        });
    }
}
ThreeObject3d.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeObject3d, deps: [{ token: OBJECT_3D_WATCHED_CONTROLLER }, { token: i1.CanvasStore }, { token: i1.InstancesStore }, { token: i1.EventsStore }, { token: i1.AnimationStore }, { token: i0.NgZone }, { token: ThreeObject3d, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });
ThreeObject3d.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeObject3d, outputs: { ready: "ready" }, usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeObject3d, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i2.Object3dControllerDirective, decorators: [{
                    type: Inject,
                    args: [OBJECT_3D_WATCHED_CONTROLLER]
                }] }, { type: i1.CanvasStore }, { type: i1.InstancesStore }, { type: i1.EventsStore }, { type: i1.AnimationStore }, { type: i0.NgZone }, { type: ThreeObject3d, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }]; }, propDecorators: { ready: [{
                type: Output
            }] } });
//# sourceMappingURL=object-3d.abstract.js.map