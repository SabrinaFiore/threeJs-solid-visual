import * as i0 from '@angular/core';
import { Injectable, EventEmitter, Component, ChangeDetectionStrategy, Self, Inject, HostBinding, Input, Output, ViewChild, Directive, NgModule, InjectionToken, Optional, ChangeDetectorRef, SkipSelf, ContentChildren, ContentChild, Pipe, ViewContainerRef, TemplateRef } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { isObservable, combineLatest, Subject, forkJoin, of, defer, throwError, shareReplay, fromEvent, asapScheduler, ReplaySubject, BehaviorSubject } from 'rxjs';
import { tap, withLatestFrom, skip, filter, mapTo, catchError, map, takeUntil, observeOn, take } from 'rxjs/operators';
import * as THREE from 'three';
import { Vector3, Vector2, Clock, WebGLRenderer, PCFSoftShadowMap, ACESFilmicToneMapping, sRGBEncoding, Scene, Camera, OrthographicCamera, PerspectiveCamera, Raycaster, Object3D, Color, Material, BufferGeometry, SpriteMaterial } from 'three';
import { __rest } from 'tslib';
import { ComponentStore } from '@ngrx/component-store';

/**
 * Generate a random Id or an Event's uuid
 *
 * @param {ThreeIntersection} event
 *
 * @internal
 * @private
 */
function makeId(event) {
    if (event) {
        return (event.eventObject || event.object).uuid + '/' + event.index;
    }
    return id();
}
const cache = {};
/**
 * Generates a short id.
 *
 * Description:
 *  A 5-character alphanumeric sequence (364 = 1.6 million)
 *  This should only be used for JavaScript specific models.
 *  http://stackoverflow.com/questions/6248666/how-to-generate-short-uid-like-ax4j9z-in-js
 *
 *  Example: `aebgf`
 */
function id() {
    let newId = ('0000' + ((Math.random() * Math.pow(36, 4)) << 0).toString(36)).slice(-4);
    newId = `a${newId}`;
    // ensure not already used
    if (!cache[newId]) {
        cache[newId] = true;
        return newId;
    }
    return id();
}

/**
 * From r3f https://github.com/pmndrs/react-three-fiber/blob/master/packages/fiber/src/core/events.ts
 */
function createEvents(canvasStateGetter, eventsStateGetter, instancesStateGetter) {
    const temp = new Vector3();
    /** Sets up defaultRaycaster */
    function prepareRay(event) {
        var _a, _b;
        const { raycaster, mouse, camera, clock, renderer, scene, internal: { size, viewport }, } = canvasStateGetter();
        const delta = clock.getDelta();
        if (raycaster && camera && renderer && scene) {
            const { offsetX, offsetY } = (_b = (_a = raycaster.computeOffsets) === null || _a === void 0 ? void 0 : _a.call(raycaster, event, {
                camera,
                clock,
                size,
                viewport,
                renderer,
                scene,
                delta,
                mouse,
            })) !== null && _b !== void 0 ? _b : event;
            const { width, height } = size;
            mouse.set((offsetX / width) * 2 - 1, -(offsetY / height) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
        }
    }
    /** Calculates delta */
    function calculateDistance(event) {
        const { internal: { initialClick }, } = eventsStateGetter();
        const dx = event.offsetX - initialClick[0];
        const dy = event.offsetY - initialClick[1];
        return Math.round(Math.sqrt(dx * dx + dy * dy));
    }
    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */
    function filterPointerEvents(objects) {
        return objects.filter((obj) => ['move', 'over', 'enter', 'out', 'leave'].some((name) => {
            var _a, _b;
            return (_b = (_a = obj.__ngt) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b[('pointer' + name)];
        }));
    }
    function intersect(filter) {
        var _a;
        const { raycaster } = canvasStateGetter();
        const { objects } = instancesStateGetter();
        // Skip event handling when noEvents is set
        if (!raycaster || (raycaster && !raycaster.enabled))
            return [];
        const seen = new Set();
        const intersections = [];
        // Allow callers to eliminate event objects
        const eventsObjects = filter
            ? filter(Object.values(objects))
            : Object.values(objects);
        // Intersect known handler objects and filter against duplicates
        const intersects = raycaster
            .intersectObjects(eventsObjects, true)
            .filter((item) => {
            const id = makeId(item);
            if (seen.has(id))
                return false;
            seen.add(id);
            return true;
        });
        // https://github.com/mrdoob/three.js/issues/16031
        // Allow custom userland intersect sort order
        // if (raycaster.filter) intersects = raycaster.filter(intersects, state);
        for (const intersect of intersects) {
            let eventObject = intersect.object;
            // Bubble event up
            while (eventObject) {
                const handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;
                if (handlers)
                    intersections.push(Object.assign(Object.assign({}, intersect), { eventObject }));
                eventObject = eventObject.parent;
            }
        }
        return intersections;
    }
    /**  Creates filtered intersects and returns an array of positive hits */
    function patchIntersects(intersections, event) {
        const { internal: { capturedMap }, } = eventsStateGetter();
        // If the interaction is captured take that into account, the captured event has to be part of the intersects
        if ('pointerId' in event && capturedMap.has(event.pointerId)) {
            intersections.push(...capturedMap.get(event.pointerId).values());
        }
        return intersections;
    }
    /**  Handles intersections by forwarding them to handlers */
    function handleIntersects(intersections, event, callback) {
        const { raycaster, mouse, camera } = canvasStateGetter();
        const { internal: eventsInternal } = eventsStateGetter();
        // If anything has been found, forward it to the event listeners
        if (intersections.length && camera) {
            const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);
            const delta = event.type === 'click' ? calculateDistance(event) : 0;
            const releasePointerCapture = (id) => event.target.releasePointerCapture(id);
            const localState = { stopped: false };
            for (const hit of intersections) {
                const hasPointerCapture = (id) => { var _a, _b; return (_b = (_a = eventsInternal.capturedMap.get(id)) === null || _a === void 0 ? void 0 : _a.has(hit.eventObject)) !== null && _b !== void 0 ? _b : false; };
                const setPointerCapture = (id) => {
                    if (eventsInternal.capturedMap.has(id)) {
                        // if the pointerId was previously captured, we add the hit to the
                        // event capturedMap.
                        eventsInternal.capturedMap.get(id).set(hit.eventObject, hit);
                    }
                    else {
                        // if the pointerId was not previously captured, we create a map
                        // containing the hitObject, and the hit. hitObject is used for
                        // faster access.
                        eventsInternal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));
                    }
                    // Call the original event now
                    event.target.setPointerCapture(id);
                };
                // Add native event props
                const extractEventProps = {};
                for (const prop in Object.getPrototypeOf(event)) {
                    // noinspection JSUnfilteredForInLoop
                    const property = event[prop];
                    // Only copy over atomics, leave functions alone as these should be
                    // called as event.nativeEvent.fn()
                    if (typeof property !== 'function') {
                        // noinspection JSUnfilteredForInLoop
                        extractEventProps[prop] = property;
                    }
                }
                const raycastEvent = Object.assign(Object.assign(Object.assign({}, hit), extractEventProps), { spaceX: mouse.x, spaceY: mouse.y, intersections, stopped: localState.stopped, delta,
                    unprojectedPoint, ray: raycaster ? raycaster.ray : null, camera, 
                    // Hijack stopPropagation, which just sets a flag
                    stopPropagation: () => {
                        // https://github.com/pmndrs/react-three-fiber/issues/596
                        // Events are not allowed to stop propagation if the pointer has been captured
                        const capturesForPointer = 'pointerId' in event &&
                            eventsInternal.capturedMap.get(event.pointerId);
                        // We only authorize stopPropagation...
                        if (
                        // ...if this pointer hasn't been captured
                        !capturesForPointer ||
                            // ... or if the hit object is capturing the pointer
                            capturesForPointer.has(hit.eventObject)) {
                            raycastEvent.stopped = localState.stopped = true;
                            // Propagation is stopped, remove all other hover records
                            // An event handler is only allowed to flush other handlers if it is hovered itself
                            if (eventsInternal.hovered.size &&
                                Array.from(eventsInternal.hovered.values()).find((i) => i.eventObject === hit.eventObject)) {
                                // Objects cannot flush out higher up objects that have already caught the event
                                const higher = intersections.slice(0, intersections.indexOf(hit));
                                cancelPointer([...higher, hit]);
                            }
                        }
                    }, target: Object.assign(Object.assign({}, event.target), { setPointerCapture,
                        releasePointerCapture,
                        hasPointerCapture }), currentTarget: Object.assign(Object.assign({}, event.currentTarget), { setPointerCapture,
                        releasePointerCapture,
                        hasPointerCapture }), sourceEvent: event, nativeEvent: event });
                // Call subscribers
                callback(raycastEvent);
                // Event bubbling may be interrupted by stopPropagation
                if (localState.stopped)
                    break;
            }
        }
        return intersections;
    }
    function cancelPointer(hits) {
        const { internal } = eventsStateGetter();
        Array.from(internal.hovered.values()).forEach((hoveredObj) => {
            var _a, _b, _c;
            // When no objects were hit or the the hovered object wasn't found underneath the cursor
            // we call onPointerOut and delete the object from the hovered-elements map
            if (!hits.length ||
                !hits.find((hit) => hit.object === hoveredObj.object && hit.index === hoveredObj.index)) {
                const eventObject = hoveredObj.eventObject;
                const handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;
                internal.hovered.delete(makeId(hoveredObj));
                if (handlers) {
                    // Clear out intersects, they are outdated by now
                    const data = Object.assign(Object.assign({}, hoveredObj), { intersections: hits || [] });
                    (_b = handlers.pointerout) === null || _b === void 0 ? void 0 : _b.call(handlers, data);
                    (_c = handlers.pointerleave) === null || _c === void 0 ? void 0 : _c.call(handlers, data);
                }
            }
        });
    }
    const handlePointer = (name) => {
        // Deal with cancellation
        switch (name) {
            case 'pointerleave':
            case 'pointercancel':
                return () => cancelPointer([]);
            case 'lostpointercapture':
                return (event) => {
                    if ('pointerId' in event) {
                        // this will be a problem if one target releases the pointerId
                        // and another one is still keeping it, as the line below
                        // indifferently deletes all capturing references.
                        const { internal: { capturedMap }, } = eventsStateGetter();
                        capturedMap.delete(event.pointerId);
                    }
                };
        }
        // Any other pointer goes here ...
        return (event) => {
            const { internal } = eventsStateGetter();
            const { objects } = instancesStateGetter();
            prepareRay(event);
            // Get fresh intersects
            const isPointerMove = name === 'pointermove';
            const filter = isPointerMove ? filterPointerEvents : undefined;
            const hits = patchIntersects(intersect(filter), event);
            // Take care of unhover
            if (isPointerMove)
                cancelPointer(hits);
            handleIntersects(hits, event, (data) => {
                var _a, _b, _c, _d;
                const eventObject = data.eventObject;
                const handlers = (_a = eventObject.__ngt) === null || _a === void 0 ? void 0 : _a.handlers;
                // Check presence of handlers
                if (!handlers)
                    return;
                if (isPointerMove) {
                    // Move event ...
                    if (handlers.pointerover ||
                        handlers.pointerenter ||
                        handlers.pointerout ||
                        handlers.pointerleave) {
                        // When enter or out is present take care of hover-state
                        const id = makeId(data);
                        const hoveredItem = internal.hovered.get(id);
                        if (!hoveredItem) {
                            // If the object wasn't previously hovered, book it and call its handler
                            internal.hovered.set(id, data);
                            (_b = handlers.pointerover) === null || _b === void 0 ? void 0 : _b.call(handlers, data);
                            (_c = handlers.pointerenter) === null || _c === void 0 ? void 0 : _c.call(handlers, data);
                        }
                        else if (hoveredItem.stopped) {
                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed
                            data.stopPropagation();
                        }
                    }
                    // Call mouse move
                    (_d = handlers.pointermove) === null || _d === void 0 ? void 0 : _d.call(handlers, data);
                }
                else {
                    // All other events ...
                    const handler = handlers === null || handlers === void 0 ? void 0 : handlers[name];
                    if (handler) {
                        // Forward all events back to their respective handlers with the exception of click events,
                        // which must use the initial target
                        if ((name !== 'click' &&
                            name !== 'contextmenu' &&
                            name !== 'dblclick') ||
                            internal.initialHits.includes(eventObject)) {
                            handler(data);
                            pointerMissed(event, Object.values(objects).filter((object) => object !== eventObject));
                        }
                    }
                }
            });
            // Save initial coordinates on pointer-down
            if (name === 'pointerdown') {
                internal.initialClick = [event.offsetX, event.offsetY];
                internal.initialHits = hits.map((hit) => hit.eventObject);
            }
            // If a click yields no results, pass it back to the user as a miss
            if ((name === 'click' || name === 'contextmenu' || name === 'dblclick') &&
                !hits.length) {
                if (calculateDistance(event) <= 2) {
                    pointerMissed(event, Object.values(objects));
                    // if (onPointerMissed) onPointerMissed();
                }
            }
        };
    };
    function pointerMissed(event, objects) {
        objects.forEach((object) => {
            var _a, _b, _c;
            return (_c = (_b = (_a = object.__ngt) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.pointermissed) === null || _c === void 0 ? void 0 : _c.call(_b, event);
        });
    }
    return { handlePointer };
}

function applyDottedPathProps(instance, key, propAtKey, isRoot = true) {
    const [first, ...paths] = key.split('.');
    const rootChild = instance[first];
    if (rootChild == null) {
        return;
    }
    if (paths.length >= 1) {
        applyDottedPathProps(rootChild, paths.join('.'), propAtKey, false);
    }
    else {
        instance[first] = propAtKey;
    }
    if (isRoot) {
        checkNeedsUpdate(rootChild);
    }
}
function checkNeedsUpdate(value) {
    if (typeof value === 'object' && 'needsUpdate' in value) {
        value['needsUpdate'] = true;
    }
}
/**
 * Apply props on instances
 *
 * @internal
 * @private
 */
function applyProps(instance, props) {
    if (!props || (props && !Object.keys(props).length))
        return;
    if ('__ngt' in props) {
        instance['__ngt'] = props['__ngt'];
    }
    const unknownInstance = instance;
    if (unknownInstance['set'] != null &&
        typeof unknownInstance['set'] === 'function') {
        unknownInstance['set'](props);
    }
    for (const [key, propAtKey] of Object.entries(props)) {
        if (key.split('.').length > 1) {
            applyDottedPathProps(instance, key, propAtKey);
        }
        else {
            const threeInstancePropAtKey = unknownInstance[key];
            if (threeInstancePropAtKey == null) {
                unknownInstance[key] = propAtKey;
            }
            else {
                if (threeInstancePropAtKey['set'] != null &&
                    typeof threeInstancePropAtKey['set'] === 'function') {
                    if (Array.isArray(propAtKey)) {
                        if (threeInstancePropAtKey['fromArray'] != null &&
                            typeof threeInstancePropAtKey['fromArray'] === 'function') {
                            threeInstancePropAtKey['fromArray'](propAtKey);
                        }
                        else {
                            threeInstancePropAtKey['set'](...propAtKey);
                        }
                    }
                    else {
                        threeInstancePropAtKey['set'](propAtKey);
                    }
                }
                else {
                    unknownInstance[key] = propAtKey;
                }
            }
            checkNeedsUpdate(propAtKey);
        }
    }
}

class ImperativeComponentStore extends ComponentStore {
    getImperativeState() {
        return this.get();
    }
}

class AnimationStore extends ImperativeComponentStore {
    constructor() {
        super({
            animations: {},
            objectSubscriptions: [],
            animationCallbacks: [],
            hasPriority: false,
        });
        this.animationsChangedEffect = this.effect((animations$) => animations$.pipe(tap((animations) => {
            const animationCallbacks = Object.values(animations);
            const hasPriority = animationCallbacks.some(({ priority }) => !!priority);
            this.patchState({ animationCallbacks, hasPriority });
        })));
        this.unregisterAnimationEffect = this.effect((uuid$) => uuid$.pipe(withLatestFrom(this.state$), tap(([uuid, { animations, objectSubscriptions }]) => {
            const subscription = objectSubscriptions.find(([objectUuid]) => objectUuid === uuid);
            if (subscription) {
                subscription[1].unsubscribe();
            }
            const _a = animations, _b = uuid, _ = _a[_b], updatedAnimations = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            this.patchState({
                animations: updatedAnimations,
                objectSubscriptions: objectSubscriptions.filter(([objectUuid]) => objectUuid !== uuid),
            });
        })));
        this.clearEffect = this.effect((trigger$) => trigger$.pipe(tap(() => {
            this.patchState((state) => {
                state.objectSubscriptions.forEach(([, subscription]) => subscription.unsubscribe());
                return { animations: {}, objectSubscriptions: [] };
            });
        })));
        this.animationsChangedEffect(this.select((s) => s.animations).pipe(skip(1)));
    }
    registerAnimation(objOrObsOrCallback, callbackOrPriority, priority = 0) {
        if (objOrObsOrCallback === undefined)
            return;
        if (typeof objOrObsOrCallback === 'function') {
            const id = makeId();
            this.patchState((state) => (Object.assign(Object.assign({}, state), { animations: Object.assign(Object.assign({}, state.animations), { [id]: {
                        obj: null,
                        callback: objOrObsOrCallback,
                        priority: callbackOrPriority || 0,
                    } }) })));
            return () => {
                this.unregisterAnimationEffect(id);
            };
        }
        if (isObservable(objOrObsOrCallback)) {
            let id = '';
            const subscription = objOrObsOrCallback
                .pipe(filter((obj) => !!obj))
                .subscribe((obj) => {
                this.patchState((state) => {
                    var _a;
                    const objectSubscriptions = state.objectSubscriptions;
                    if ((_a = objectSubscriptions[objectSubscriptions.length - 1]) === null || _a === void 0 ? void 0 : _a[0]) {
                        objectSubscriptions[objectSubscriptions.length - 1][0] = obj.uuid;
                    }
                    id = obj.uuid;
                    return {
                        animations: Object.assign(Object.assign({}, state.animations), { [id]: {
                                obj,
                                callback: callbackOrPriority,
                                priority,
                            } }),
                        objectSubscriptions,
                    };
                });
            });
            this.patchState((state) => ({
                objectSubscriptions: [
                    ...state.objectSubscriptions,
                    [null, subscription],
                ],
            }));
            return () => {
                this.unregisterAnimationEffect(id);
            };
        }
        const uuid = objOrObsOrCallback.uuid;
        this.patchState((state) => ({
            animations: Object.assign(Object.assign({}, state.animations), { [uuid]: {
                    obj: objOrObsOrCallback,
                    callback: callbackOrPriority,
                    priority,
                } }),
        }));
        return () => {
            this.unregisterAnimationEffect(uuid);
        };
    }
    ngOnDestroy() {
        this.clearEffect();
        super.ngOnDestroy();
    }
}
AnimationStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: AnimationStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
AnimationStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: AnimationStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: AnimationStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

const position = new Vector3();
const defaultTarget = new Vector3();
const isOrthographicCamera = (def) => def && def.isOrthographicCamera;
class CanvasStore extends ImperativeComponentStore {
    constructor() {
        super({
            isOrthographic: false,
            isLinear: false,
            shadows: false,
            mouse: new Vector2(),
            clock: new Clock(),
            internal: {
                active: false,
                size: { width: 0, height: 0 },
                dpr: 1,
                viewport: {
                    initialDpr: 1,
                    dpr: 1,
                    width: 0,
                    height: 0,
                    aspect: 0,
                    distance: 0,
                    factor: 0,
                    getCurrentViewport: (camera = this.getImperativeState().camera, target = defaultTarget, size = this.getImperativeState().internal.size) => {
                        const { width, height } = size;
                        const aspect = width / height;
                        const distance = camera
                            .getWorldPosition(position)
                            .distanceTo(target);
                        if (isOrthographicCamera(camera)) {
                            return {
                                width: width / camera.zoom,
                                height: height / camera.zoom,
                                factor: 1,
                                distance,
                                aspect,
                            };
                        }
                        const fov = (camera.fov * Math.PI) / 180; // convert vertical fov to radians
                        const h = 2 * Math.tan(fov / 2) * distance; // visible height
                        const w = h * (width / height);
                        return {
                            width: w,
                            height: h,
                            factor: width / w,
                            distance,
                            aspect,
                        };
                    },
                },
            },
        });
        this.renderer$ = this.select((s) => s.renderer);
        this.camera$ = this.select((s) => s.camera);
        this.scene$ = this.select((s) => s.scene);
        this.raycaster$ = this.select((s) => s.raycaster);
        this.isOrthographic$ = this.select((s) => s.isOrthographic);
        this.isLinear$ = this.select((s) => s.isLinear);
        this.shadows$ = this.select((s) => s.shadows);
        this.active$ = this.select((s) => s.internal.active);
        this.canvasInternal$ = this.select((s) => s.internal);
        this.setIsOrthographic = this.updater((state, isOrthographic) => (Object.assign(Object.assign({}, state), { isOrthographic })));
        this.setIsLinear = this.updater((state, isLinear) => (Object.assign(Object.assign({}, state), { isLinear })));
        this.setShadows = this.updater((state, shadows) => (Object.assign(Object.assign({}, state), { shadows })));
        this.setSize = this.updater((state, size) => (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { size }) })));
        this.setDpr = this.updater((state, dpr) => (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { dpr }) })));
        this.setViewport = this.updater((state) => (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { viewport: Object.assign(Object.assign(Object.assign({}, state.internal.viewport), state.internal.viewport.getCurrentViewport(state.camera, defaultTarget, state.internal.size)), { dpr: state.internal.dpr }) }) })));
        this.setActive = this.updater((state, active) => (Object.assign(Object.assign({}, state), { internal: Object.assign(Object.assign({}, state.internal), { active }) })));
        this.initRendererEffect = this.effect((canvas$) => {
            return canvas$.pipe(withLatestFrom(this.canvasInternal$, this.isLinear$, this.shadows$), tap(([canvas, { size, dpr }, isLinear, shadows]) => {
                const renderer = new WebGLRenderer({
                    canvas,
                    antialias: true,
                    powerPreference: 'high-performance',
                    alpha: true,
                });
                if (shadows) {
                    renderer.shadowMap.enabled = true;
                    if (typeof shadows === 'object')
                        Object.assign(renderer.shadowMap, shadows);
                    else
                        renderer.shadowMap.type = PCFSoftShadowMap;
                }
                if (!isLinear) {
                    renderer.toneMapping = ACESFilmicToneMapping;
                    renderer.outputEncoding = sRGBEncoding;
                }
                renderer.setClearAlpha(0);
                renderer.setPixelRatio(dpr);
                renderer.setSize(size.width, size.height);
                this.patchState({ renderer });
            }));
        });
        this.initSceneEffect = this.effect((sceneOptions$) => sceneOptions$.pipe(tap((sceneOptions) => {
            const scene = new Scene();
            applyProps(scene, sceneOptions);
            this.patchState({ scene });
        })));
        this.initCameraEffect = this.effect((cameraOptions$) => cameraOptions$.pipe(withLatestFrom(this.isOrthographic$, this.canvasInternal$), tap(([cameraOptions, isOrthographic, { size }]) => {
            var _a;
            const isCamera = cameraOptions instanceof Camera;
            let camera;
            if (isCamera) {
                camera = cameraOptions;
            }
            else {
                if (isOrthographic) {
                    camera = new OrthographicCamera(0, 0, 0, 0, 0.1, 1000);
                    camera.zoom = 100;
                }
                else {
                    camera = new PerspectiveCamera(75, (_a = size.width / size.height) !== null && _a !== void 0 ? _a : 0, 0.1, 1000);
                }
                camera.position.z = 5;
                applyProps(camera, cameraOptions);
                // Update projection matrix after applying props
                camera.updateProjectionMatrix();
            }
            // look at center by default
            camera.lookAt(0, 0, 0);
            this.patchState({ camera });
            this.setViewport();
        })));
        this.initRaycasterEffect = this.effect((raycasterOptions$) => raycasterOptions$.pipe(tap((raycasterOptions) => {
            const raycaster = new Raycaster();
            raycaster.enabled = true;
            applyProps(raycaster, raycasterOptions);
            this.patchState({ raycaster });
        })));
        this.windowResizeEffect = this.effect((params$) => params$.pipe(withLatestFrom(this.renderer$, this.camera$), tap(([{ dpr, size }, renderer, camera]) => {
            if (camera.type === 'PerspectiveCamera') {
                camera.aspect = size.width / size.height;
            }
            else {
                camera.left = size.width / -2;
                camera.right = size.width / 2;
                camera.top = size.height / 2;
                camera.bottom = size.height / -2;
            }
            camera.updateProjectionMatrix();
            camera.updateMatrixWorld();
            renderer.setPixelRatio(dpr);
            renderer.setSize(size.width, size.height);
            this.setSize(size);
            this.setDpr(dpr);
            this.setViewport();
        })));
        this.setActive(combineLatest([
            this.renderer$,
            this.camera$,
            this.scene$,
            this.raycaster$,
        ]).pipe(filter((coreObjects) => coreObjects.every(Boolean)), mapTo(true)));
    }
    ngOnDestroy() {
        const { renderer } = this.getImperativeState();
        if (renderer) {
            renderer.renderLists.dispose();
            renderer.forceContextLoss();
        }
        super.ngOnDestroy();
    }
}
CanvasStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CanvasStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

class InstancesStore extends ImperativeComponentStore {
    constructor() {
        super({ materials: {}, bufferGeometries: {}, objects: {} });
        this.saveMaterial = this.updater((state, { material, id = material.uuid }) => (Object.assign(Object.assign({}, state), { materials: Object.assign(Object.assign({}, state.materials), { [id]: material }) })));
        this.removeMaterial = this.updater((state, id) => {
            const _a = state.materials, _b = id, _ = _a[_b], materials = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            return Object.assign(Object.assign({}, state), { materials });
        });
        this.saveBufferGeometry = this.updater((state, { bufferGeometry, id = bufferGeometry.uuid }) => (Object.assign(Object.assign({}, state), { bufferGeometries: Object.assign(Object.assign({}, state.bufferGeometries), { [id]: bufferGeometry }) })));
        this.removeBufferGeometry = this.updater((state, id) => {
            const _a = state.bufferGeometries, _b = id, _ = _a[_b], bufferGeometries = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            return Object.assign(Object.assign({}, state), { bufferGeometries });
        });
        this.saveObject = this.updater((state, obj) => (Object.assign(Object.assign({}, state), { objects: Object.assign(Object.assign({}, state.objects), { [obj.uuid]: obj }) })));
        this.removeObject = this.updater((state, id) => {
            const _a = state.objects, _b = id, _ = _a[_b], objects = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            return Object.assign(Object.assign({}, state), { objects });
        });
    }
}
InstancesStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: InstancesStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
InstancesStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: InstancesStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: InstancesStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

const events = {
    click: false,
    contextmenu: false,
    dblclick: false,
    wheel: true,
    pointerdown: true,
    pointerup: true,
    pointerleave: true,
    pointermove: true,
    pointercancel: true,
    lostpointercapture: true,
};
class EventsStore extends ImperativeComponentStore {
    constructor(canvasStore, instancesStore) {
        super({
            connected: false,
            internal: {
                interaction: [],
                hovered: new Map(),
                capturedMap: new Map(),
                initialClick: [0, 0],
                initialHits: [],
            },
        });
        this.canvasStore = canvasStore;
        this.instancesStore = instancesStore;
        this.initHandlersEffect = this.effect((trigger$) => trigger$.pipe(tap(() => {
            const { handlePointer } = createEvents(() => this.canvasStore.getImperativeState(), () => this.getImperativeState(), () => this.instancesStore.getImperativeState());
            this.patchState({
                handlers: Object.keys(events).reduce((handlers, supportedEventName) => {
                    handlers[supportedEventName] = handlePointer(supportedEventName);
                    return handlers;
                }, {}),
            });
        })));
        this.connectEffect = this.effect((target$) => target$.pipe(tap((target) => {
            this.disconnectEffect();
            const { handlers } = this.getImperativeState();
            this.patchState({ connected: target });
            Object.entries(handlers !== null && handlers !== void 0 ? handlers : []).forEach(([name, event]) => {
                const passive = events[name];
                target.addEventListener(name, event, { passive });
            });
        })));
        this.disconnectEffect = this.effect((trigger$) => trigger$.pipe(tap(() => {
            const { handlers, connected } = this.getImperativeState();
            if (connected) {
                Object.entries(handlers !== null && handlers !== void 0 ? handlers : []).forEach(([name, event]) => {
                    if (connected instanceof HTMLElement) {
                        connected.removeEventListener(name, event);
                    }
                });
                this.patchState({ connected: false });
            }
        })));
        this.initHandlersEffect();
    }
    ngOnDestroy() {
        this.disconnectEffect();
        super.ngOnDestroy();
    }
}
EventsStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: EventsStore, deps: [{ token: CanvasStore }, { token: InstancesStore }], target: i0.ɵɵFactoryTarget.Injectable });
EventsStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: EventsStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: EventsStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CanvasStore }, { type: InstancesStore }]; } });

class LoopService {
    // TODO: rethink limit 60fps
    // private readonly interval = 1 / 60; // 60fps;
    // private internalDelta = 0;
    constructor(canvasStore, animationStore) {
        this.canvasStore = canvasStore;
        this.animationStore = animationStore;
        this.loopClock = new Clock();
    }
    start() {
        const { renderer } = this.canvasStore.getImperativeState();
        if (renderer) {
            renderer.setAnimationLoop(() => {
                this.tick(this.loopClock.getDelta());
            });
        }
    }
    stop() {
        const { renderer } = this.canvasStore.getImperativeState();
        if (renderer) {
            renderer.setAnimationLoop(null);
        }
    }
    tick(delta) {
        // this.internalDelta += delta;
        //
        // if (this.internalDelta >= this.interval) {
        //   const {
        //     renderer,
        //     scene,
        //     camera,
        //     internal: { size, viewport },
        //     clock,
        //     mouse,
        //   } = this.canvasStore.getImperativeState();
        //   const { animationCallbacks, hasPriority } =
        //     this.animationStore.getImperativeState();
        //
        //   if (renderer && scene && camera) {
        //     if (hasPriority) {
        //       animationCallbacks.sort(
        //         ({ priority: a = 0 }, { priority: b = 0 }) => a - b
        //       );
        //     } else {
        //       renderer.render(scene, camera);
        //     }
        //
        //     const renderState = {
        //       clock,
        //       camera,
        //       scene,
        //       renderer,
        //       mouse,
        //       size,
        //       viewport,
        //       delta,
        //     };
        //     for (const animationCallback of animationCallbacks) {
        //       if (animationCallback.obj) {
        //         animationCallback.callback(animationCallback.obj, renderState);
        //       } else {
        //         animationCallback.callback(renderState);
        //       }
        //     }
        //   }
        //
        //   this.internalDelta = this.internalDelta % this.interval;
        // }
        const { renderer, scene, camera, internal: { size, viewport }, clock, mouse, } = this.canvasStore.getImperativeState();
        const { animationCallbacks, hasPriority } = this.animationStore.getImperativeState();
        if (renderer && scene && camera) {
            if (hasPriority) {
                animationCallbacks.sort(({ priority: a = 0 }, { priority: b = 0 }) => a - b);
            }
            else {
                renderer.render(scene, camera);
            }
            const renderState = {
                clock,
                camera,
                scene,
                renderer,
                mouse,
                size,
                viewport,
                delta,
            };
            for (const animationCallback of animationCallbacks) {
                if (animationCallback.obj) {
                    animationCallback.callback(animationCallback.obj, renderState);
                }
                else {
                    animationCallback.callback(renderState);
                }
            }
        }
    }
    ngOnDestroy() {
        this.stop();
    }
}
LoopService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: LoopService, deps: [{ token: CanvasStore }, { token: AnimationStore }], target: i0.ɵɵFactoryTarget.Injectable });
LoopService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: LoopService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: LoopService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CanvasStore }, { type: AnimationStore }]; } });

class DestroyedService extends Subject {
    ngOnDestroy() {
        this.next();
        this.complete();
    }
}
DestroyedService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: DestroyedService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
DestroyedService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: DestroyedService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: DestroyedService, decorators: [{
            type: Injectable
        }] });

class LoaderService {
    constructor() {
        this.cached = new Map();
    }
    use(loaderConstructor, input, extensions, onProgress) {
        const keys = (Array.isArray(input) ? input : [input]);
        const loader = new loaderConstructor();
        if (extensions) {
            extensions(loader);
        }
        const results$ = forkJoin(keys.map((key) => {
            if (this.cached.has(key)) {
                return of(this.cached.get(key));
            }
            return defer(() => loader.loadAsync(key, onProgress)).pipe(tap((data) => {
                if (data.scene) {
                    Object.assign(data, this.buildGraph(data.scene));
                }
                this.cached.set(key, data);
            }), catchError((err) => {
                console.error(`Error loading ${key}: ${err.message}`);
                return throwError(err);
            }));
        }));
        return defer(() => Array.isArray(input)
            ? results$
            : results$.pipe(map((results) => results[0]))).pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    ngOnDestroy() {
        this.cached.clear();
    }
    buildGraph(object) {
        const data = { nodes: {}, materials: {} };
        if (object) {
            object.traverse((obj) => {
                if (obj.name) {
                    data.nodes[obj.name] = obj;
                }
                if (obj.material &&
                    !data.materials[obj
                        .material.name]) {
                    data.materials[obj
                        .material.name] = obj.material;
                }
            });
        }
        return data;
    }
}
LoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: LoaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: LoaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: LoaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CanvasComponent {
    constructor(canvasStore, animationStore, eventsStore, loopService, ngZone, hostElement, document, destroyed) {
        this.canvasStore = canvasStore;
        this.animationStore = animationStore;
        this.eventsStore = eventsStore;
        this.loopService = loopService;
        this.ngZone = ngZone;
        this.hostElement = hostElement;
        this.document = document;
        this.destroyed = destroyed;
        this.hostClass = true;
        this.raycaster = {};
        this.created = new EventEmitter();
    }
    set orthographic(v) {
        this.canvasStore.setIsOrthographic(v);
    }
    set linear(v) {
        this.canvasStore.setIsLinear(v);
    }
    set shadows(v) {
        this.canvasStore.setShadows(v);
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            var _a;
            this.canvasStore.setSize({
                width: this.hostElement.nativeElement.clientWidth,
                height: this.hostElement.nativeElement.clientHeight,
            });
            this.canvasStore.setDpr(((_a = this.document.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) || 1);
            this.canvasStore.initRendererEffect(this.rendererCanvas.nativeElement);
            this.canvasStore.initSceneEffect(this.scene);
            this.canvasStore.initCameraEffect(this.camera);
            this.canvasStore.initRaycasterEffect(this.raycaster);
            this.initWindowResizeListener();
            this.initActiveListener();
        });
    }
    initWindowResizeListener() {
        var _a;
        if ((_a = this.document) === null || _a === void 0 ? void 0 : _a.defaultView) {
            fromEvent(this.document.defaultView, 'resize')
                .pipe(takeUntil(this.destroyed))
                .subscribe(() => {
                this.ngZone.runOutsideAngular(() => {
                    var _a;
                    this.canvasStore.windowResizeEffect({
                        size: {
                            width: this.hostElement.nativeElement.clientWidth,
                            height: this.hostElement.nativeElement.clientHeight,
                        },
                        dpr: ((_a = this.document.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) || 1,
                    });
                });
            });
        }
    }
    initActiveListener() {
        this.canvasStore.active$
            .pipe(takeUntil(this.destroyed), observeOn(asapScheduler))
            .subscribe((active) => {
            this.ngZone.runOutsideAngular(() => {
                if (active) {
                    const { renderer, camera, scene } = this.canvasStore.getImperativeState();
                    if (renderer && camera && scene) {
                        this.created.emit({ gl: renderer, camera, scene });
                        this.eventsStore.connectEffect(renderer.domElement);
                        this.loopService.start();
                    }
                }
            });
        });
    }
}
CanvasComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasComponent, deps: [{ token: CanvasStore, self: true }, { token: AnimationStore, self: true }, { token: EventsStore, self: true }, { token: LoopService, self: true }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: DOCUMENT }, { token: DestroyedService }], target: i0.ɵɵFactoryTarget.Component });
CanvasComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: CanvasComponent, selector: "ngt-canvas", inputs: { orthographic: "orthographic", linear: "linear", shadows: "shadows", camera: "camera", scene: "scene", raycaster: "raycaster" }, outputs: { created: "created" }, host: { properties: { "class.ngt-canvas": "this.hostClass" } }, providers: [
        CanvasStore,
        EventsStore,
        InstancesStore,
        AnimationStore,
        LoopService,
        DestroyedService,
    ], viewQueries: [{ propertyName: "rendererCanvas", first: true, predicate: ["rendererCanvas"], descendants: true, static: true }], exportAs: ["ngtCanvas"], ngImport: i0, template: ` <canvas #rendererCanvas></canvas> `, isInline: true, styles: ["\n      :host {\n        display: block;\n        position: relative;\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n      }\n\n      :host canvas {\n        display: block;\n      }\n    "], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: CanvasComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-canvas',
                    exportAs: 'ngtCanvas',
                    template: ` <canvas #rendererCanvas></canvas> `,
                    styles: [
                        `
      :host {
        display: block;
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      :host canvas {
        display: block;
      }
    `,
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        CanvasStore,
                        EventsStore,
                        InstancesStore,
                        AnimationStore,
                        LoopService,
                        DestroyedService,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: CanvasStore, decorators: [{
                    type: Self
                }] }, { type: AnimationStore, decorators: [{
                    type: Self
                }] }, { type: EventsStore, decorators: [{
                    type: Self
                }] }, { type: LoopService, decorators: [{
                    type: Self
                }] }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: DestroyedService }]; }, propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.ngt-canvas']
            }], orthographic: [{
                type: Input
            }], linear: [{
                type: Input
            }], shadows: [{
                type: Input
            }], camera: [{
                type: Input
            }], scene: [{
                type: Input
            }], raycaster: [{
                type: Input
            }], created: [{
                type: Output
            }], rendererCanvas: [{
                type: ViewChild,
                args: ['rendererCanvas', { static: true }]
            }] } });

class Controller {
    constructor() {
        this.change$ = new ReplaySubject(1);
    }
    ngOnChanges(changes) {
        this.change$.next(changes);
    }
}
Controller.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: Controller, deps: [], target: i0.ɵɵFactoryTarget.Directive });
Controller.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: Controller, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: Controller, decorators: [{
            type: Directive
        }] });

// GENERATED
class Object3dControllerDirective extends Controller {
    constructor() {
        super(...arguments);
        this.castShadow = false;
        this.receiveShadow = false;
        this.visible = true;
        this.matrixAutoUpdate = true;
        this.appendMode = 'immediate';
        // events
        this.click = new EventEmitter();
        this.contextmenu = new EventEmitter();
        this.dblclick = new EventEmitter();
        this.pointerup = new EventEmitter();
        this.pointerdown = new EventEmitter();
        this.pointerover = new EventEmitter();
        this.pointerout = new EventEmitter();
        this.pointerenter = new EventEmitter();
        this.pointerleave = new EventEmitter();
        this.pointermove = new EventEmitter();
        this.pointermissed = new EventEmitter();
        this.pointercancel = new EventEmitter();
        this.wheel = new EventEmitter();
    }
}
Object3dControllerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: Object3dControllerDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
Object3dControllerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: Object3dControllerDirective, selector: "\n    ngt-primitive[o3d],\n    ngt-mesh[o3d],\n    ngt-instanced-mesh[o3d],\n    ngt-skinned-mesh[o3d],\n    ngt-bone[o3d],\n    ngt-group[o3d],\n    ngt-lod[o3d],\n    ngt-scene[o3d],\n    ngt-points[o3d],\n    ngt-cube-camera[o3d],\n    ngt-contact-shadows[o3d],\n    ngt-html[o3d],\n    ngt-light-probe[o3d],\n    ngt-ambient-light[o3d],\n    ngt-ambient-light-probe[o3d],\n    ngt-hemisphere-light[o3d],\n    ngt-hemisphere-light-probe[o3d],\n    ngt-directional-light[o3d],\n    ngt-point-light[o3d],\n    ngt-spot-light[o3d],\n    ngt-rect-area-light[o3d],\n    ngt-arrow-helper[o3d],\n    ngt-axes-helper[o3d],\n    ngt-box-helper[o3d],\n    ngt-box3-helper[o3d],\n    ngt-grid-helper[o3d],\n    ngt-camera-helper[o3d],\n    ngt-directional-light-helper[o3d],\n    ngt-hemisphere-light-helper[o3d],\n    ngt-plane-helper[o3d],\n    ngt-point-light-helper[o3d],\n    ngt-polar-grid-helper[o3d],\n    ngt-skeleton-helper[o3d],\n    ngt-spot-light-helper[o3d],\n    ngt-line[o3d],\n    ngt-line-loop[o3d],\n    ngt-line-segments[o3d],\n    ngt-sprite[o3d],\n    ngt-camera[o3d],\n    ngt-perspective-camera[o3d],\n    ngt-orthographic-camera[o3d],\n    ngt-array-camera[o3d],\n    ngt-stereo-camera[o3d]\n  ", inputs: { name: "name", position: "position", rotation: "rotation", quaternion: "quaternion", scale: "scale", color: "color", userData: "userData", dispose: "dispose", castShadow: "castShadow", receiveShadow: "receiveShadow", visible: "visible", matrixAutoUpdate: "matrixAutoUpdate", appendMode: "appendMode", appendTo: "appendTo" }, outputs: { click: "click", contextmenu: "contextmenu", dblclick: "dblclick", pointerup: "pointerup", pointerdown: "pointerdown", pointerover: "pointerover", pointerout: "pointerout", pointerenter: "pointerenter", pointerleave: "pointerleave", pointermove: "pointermove", pointermissed: "pointermissed", pointercancel: "pointercancel", wheel: "wheel" }, exportAs: ["ngtObject3dController"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: Object3dControllerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `
    ngt-primitive[o3d],
    ngt-mesh[o3d],
    ngt-instanced-mesh[o3d],
    ngt-skinned-mesh[o3d],
    ngt-bone[o3d],
    ngt-group[o3d],
    ngt-lod[o3d],
    ngt-scene[o3d],
    ngt-points[o3d],
    ngt-cube-camera[o3d],
    ngt-contact-shadows[o3d],
    ngt-html[o3d],
    ngt-light-probe[o3d],
    ngt-ambient-light[o3d],
    ngt-ambient-light-probe[o3d],
    ngt-hemisphere-light[o3d],
    ngt-hemisphere-light-probe[o3d],
    ngt-directional-light[o3d],
    ngt-point-light[o3d],
    ngt-spot-light[o3d],
    ngt-rect-area-light[o3d],
    ngt-arrow-helper[o3d],
    ngt-axes-helper[o3d],
    ngt-box-helper[o3d],
    ngt-box3-helper[o3d],
    ngt-grid-helper[o3d],
    ngt-camera-helper[o3d],
    ngt-directional-light-helper[o3d],
    ngt-hemisphere-light-helper[o3d],
    ngt-plane-helper[o3d],
    ngt-point-light-helper[o3d],
    ngt-polar-grid-helper[o3d],
    ngt-skeleton-helper[o3d],
    ngt-spot-light-helper[o3d],
    ngt-line[o3d],
    ngt-line-loop[o3d],
    ngt-line-segments[o3d],
    ngt-sprite[o3d],
    ngt-camera[o3d],
    ngt-perspective-camera[o3d],
    ngt-orthographic-camera[o3d],
    ngt-array-camera[o3d],
    ngt-stereo-camera[o3d]
  `,
                    exportAs: 'ngtObject3dController',
                }]
        }], propDecorators: { name: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], quaternion: [{
                type: Input
            }], scale: [{
                type: Input
            }], color: [{
                type: Input
            }], userData: [{
                type: Input
            }], dispose: [{
                type: Input
            }], castShadow: [{
                type: Input
            }], receiveShadow: [{
                type: Input
            }], visible: [{
                type: Input
            }], matrixAutoUpdate: [{
                type: Input
            }], appendMode: [{
                type: Input
            }], appendTo: [{
                type: Input
            }], click: [{
                type: Output
            }], contextmenu: [{
                type: Output
            }], dblclick: [{
                type: Output
            }], pointerup: [{
                type: Output
            }], pointerdown: [{
                type: Output
            }], pointerover: [{
                type: Output
            }], pointerout: [{
                type: Output
            }], pointerenter: [{
                type: Output
            }], pointerleave: [{
                type: Output
            }], pointermove: [{
                type: Output
            }], pointermissed: [{
                type: Output
            }], pointercancel: [{
                type: Output
            }], wheel: [{
                type: Output
            }] } });

class ThreeCoreModule {
}
ThreeCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ThreeCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeCoreModule, declarations: [CanvasComponent, Object3dControllerDirective], exports: [CanvasComponent, Object3dControllerDirective] });
ThreeCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeCoreModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [CanvasComponent, Object3dControllerDirective],
                    exports: [CanvasComponent, Object3dControllerDirective],
                }]
        }] });

const OBJECT_3D_WATCHED_CONTROLLER = new InjectionToken('Watched Object3D Controller');
const OBJECT_3D_CONTROLLER_PROVIDER = [
    DestroyedService,
    {
        provide: OBJECT_3D_WATCHED_CONTROLLER,
        deps: [
            [new Optional(), Object3dControllerDirective],
            ChangeDetectorRef,
            DestroyedService,
        ],
        useFactory: object3dWatchedControllerFactory,
    },
];
function object3dWatchedControllerFactory(controller, changeDetectorRef, destroy$) {
    if (!controller)
        return null;
    controller.change$.pipe(takeUntil(destroy$)).subscribe(() => {
        changeDetectorRef.markForCheck();
    });
    return controller;
}

class AnimationLoopParticipant {
    constructor(animationStore, ngZone) {
        this.animationStore = animationStore;
        this.ngZone = ngZone;
        this.animateReady = new EventEmitter();
    }
    participate(animateObject) {
        this.ngZone.runOutsideAngular(() => {
            if (this.animateReady.observed) {
                if (animateObject instanceof Object3D) {
                    this.animateTeardown = this.animationStore.registerAnimation(animateObject, (obj, state) => {
                        this.animateReady.emit({
                            animateObject: obj,
                            renderState: state,
                        });
                    });
                }
                else {
                    this.animateTeardown = this.animationStore.registerAnimation((state) => {
                        this.animateReady.emit({
                            animateObject,
                            renderState: state,
                        });
                    });
                }
            }
        });
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.animateTeardown) {
                this.animateTeardown();
            }
        });
    }
}
AnimationLoopParticipant.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: AnimationLoopParticipant, deps: [{ token: AnimationStore }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
AnimationLoopParticipant.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: AnimationLoopParticipant, outputs: { animateReady: "animateReady" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: AnimationLoopParticipant, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: AnimationStore }, { type: i0.NgZone }]; }, propDecorators: { animateReady: [{
                type: Output
            }] } });

class ThreeObject3d extends AnimationLoopParticipant {
    constructor(object3dController, canvasStore, instancesStore, eventsStore, animationStore, ngZone, parentObjectDirective) {
        super(animationStore, ngZone);
        this.object3dController = object3dController;
        this.canvasStore = canvasStore;
        this.instancesStore = instancesStore;
        this.eventsStore = eventsStore;
        this.animationStore = animationStore;
        this.ngZone = ngZone;
        this.parentObjectDirective = parentObjectDirective;
        this.$object3d = new BehaviorSubject(null);
        this.ready = this.object3d$.pipe(filter(Boolean));
        this.changesSubscription = object3dController.change$.subscribe(() => {
            if (this.object3d) {
                this.applyCustomProps();
            }
            if (this.inputChangeHandler) {
                this.inputChangeHandler();
            }
        });
    }
    get object3d$() {
        return this.$object3d.asObservable();
    }
    ngOnChanges() {
        if (this.object3d) {
            this.applyCustomProps();
        }
    }
    init() {
        this.ngZone.runOutsideAngular(() => {
            this.initObject();
            if (this.object3d) {
                this.applyCustomProps();
                applyProps(this.object3d, {
                    __ngt: {
                        canvasStateGetter: () => this.canvasStore.getImperativeState(),
                        eventsStateGetter: () => this.eventsStore.getImperativeState(),
                        handlers: this.applyEvents(),
                    },
                });
                this.instancesStore.saveObject(this.object3d);
                this.appendToParent();
                this.objectReady();
            }
        });
    }
    addToScene() {
        const { scene } = this.canvasStore.getImperativeState();
        if (scene) {
            scene.add(this.object3d);
        }
    }
    addToParent() {
        if (this.parentObjectDirective) {
            this.parentObjectDirective.object3d.add(this.object3d);
        }
        else {
            this.addToScene();
        }
    }
    remove() {
        if (this.object3dController.appendTo) {
            this.object3dController.appendTo.remove(this.object3d);
        }
        else if (this.parentObjectDirective &&
            this.object3dController.appendMode === 'immediate') {
            this.parentObjectDirective.object3d.remove(this.object3d);
        }
        else {
            const { scene } = this.canvasStore.getImperativeState();
            if (scene) {
                scene.remove(this.object3d);
            }
        }
        this.object3d.clear();
    }
    objectReady() {
        this.$object3d.next(this.object3d);
        this.participate(this.object3d);
    }
    applyCustomProps() {
        this.ngZone.runOutsideAngular(() => {
            const customProps = {
                castShadow: this.object3dController.castShadow,
                receiveShadow: this.object3dController.receiveShadow,
                visible: this.object3dController.visible,
                matrixAutoUpdate: this.object3dController.matrixAutoUpdate,
            };
            if (this.object3dController.name) {
                customProps['name'] = this.object3dController.name;
            }
            if (this.object3dController.position) {
                customProps['position'] = this.object3dController.position;
            }
            if (this.object3dController.rotation) {
                customProps['rotation'] = this.object3dController.rotation;
            }
            else if (this.object3dController.quaternion) {
                customProps['quaternion'] = this.object3dController.quaternion;
            }
            if (this.object3dController.scale) {
                customProps['scale'] = this.object3dController.scale;
            }
            if (this.object3dController.userData) {
                customProps['userData'] = this.object3dController.userData;
            }
            if (this.object3dController.color) {
                this.object3dController.color = Array.isArray(this.object3dController.color)
                    ? new Color(...this.object3dController.color)
                    : new Color(this.object3dController.color);
                if (!this.canvasStore.getImperativeState().isLinear) {
                    this.object3dController.color.convertSRGBToLinear();
                }
                customProps['color'] = this.object3dController.color;
            }
            if (this.object3dController.dispose) {
                customProps['dispose'] = this.object3dController.dispose;
            }
            this.object3dController.change$.pipe(take(1)).subscribe((changes) => {
                if (changes) {
                    for (const [inputName, inputChange] of Object.entries(changes)) {
                        if (!inputChange.isFirstChange() ||
                            [
                                'name',
                                'position',
                                'rotation',
                                'quaternion',
                                'scale',
                                'userData',
                                'color',
                                'dispose',
                                'castShadow',
                                'receiveShadow',
                                'visible',
                                'matrixAutoUpdate',
                            ].includes(inputName) // skip 12 common inputs
                        ) {
                            continue;
                        }
                        customProps[inputName] = inputChange.currentValue;
                    }
                }
            });
            applyProps(this.object3d, customProps);
            this.object3d.updateMatrix();
        });
    }
    applyEvents() {
        const handlers = {};
        [
            'click',
            'contextmenu',
            'dblclick',
            'pointerup',
            'pointerdown',
            'pointerover',
            'pointerout',
            'pointerenter',
            'pointerleave',
            'pointermove',
            'pointermissed',
            'pointercancel',
            'wheel',
        ].forEach((eventName) => {
            if (this.object3dController[eventName].observed) {
                handlers[eventName] = (event) => {
                    this.ngZone.run(() => {
                        this.object3dController[eventName].emit(event);
                    });
                };
            }
        });
        return handlers;
    }
    appendToParent() {
        if (this.object3dController.appendTo) {
            this.object3dController.appendTo.add(this.object3d);
            return;
        }
        if (this.object3dController.appendMode === 'root') {
            this.addToScene();
            return;
        }
        if (this.object3dController.appendMode === 'immediate') {
            this.addToParent();
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.changesSubscription) {
            this.changesSubscription.unsubscribe();
        }
        this.ngZone.runOutsideAngular(() => {
            if (this.object3d) {
                this.remove();
                this.instancesStore.removeObject(this.object3d.uuid);
                this.animationStore.unregisterAnimationEffect(this.object3d.uuid);
            }
        });
    }
}
ThreeObject3d.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeObject3d, deps: [{ token: OBJECT_3D_WATCHED_CONTROLLER }, { token: CanvasStore }, { token: InstancesStore }, { token: EventsStore }, { token: AnimationStore }, { token: i0.NgZone }, { token: ThreeObject3d, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });
ThreeObject3d.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeObject3d, outputs: { ready: "ready" }, usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeObject3d, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: Object3dControllerDirective, decorators: [{
                    type: Inject,
                    args: [OBJECT_3D_WATCHED_CONTROLLER]
                }] }, { type: CanvasStore }, { type: InstancesStore }, { type: EventsStore }, { type: AnimationStore }, { type: i0.NgZone }, { type: ThreeObject3d, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }]; }, propDecorators: { ready: [{
                type: Output
            }] } });

class ThreeObject3dMaterialGeometry extends ThreeObject3d {
    set extraArgs(v) {
        this._extraArgs = v;
    }
    ngAfterContentInit() {
        this.init();
    }
    initObject() {
        if (this.canCreate()) {
            const material = this.getMaterial();
            const geometry = this.getGeometry();
            this._objectMaterialGeometry = new this.objectType(geometry, material, ...(this._extraArgs || []));
            if (this.morphTargetDictionary &&
                'morphTargetDictionary' in this._objectMaterialGeometry) {
                this._objectMaterialGeometry.morphTargetDictionary =
                    this.morphTargetDictionary;
            }
            if (this.morphTargetInfluences &&
                'morphTargetInfluences' in this._objectMaterialGeometry) {
                this._objectMaterialGeometry.morphTargetInfluences =
                    this.morphTargetInfluences;
            }
            if (this.customize) {
                this.customize();
            }
        }
    }
    canCreate() {
        return true;
    }
    get object3d() {
        return this._objectMaterialGeometry;
    }
    getMaterial() {
        if (this.material) {
            if ((Array.isArray(this.material) &&
                this.material[0] instanceof Material) ||
                this.material instanceof Material) {
                return this.material;
            }
            if (Array.isArray(this.material)) {
                return this.material.map((materialId) => this.instancesStore.getImperativeState().materials[materialId]);
            }
            return this.instancesStore.getImperativeState().materials[this.material];
        }
        return undefined;
    }
    getGeometry() {
        if (this.geometry) {
            if (this.geometry instanceof BufferGeometry) {
                return this.geometry;
            }
            return this.instancesStore.getImperativeState().bufferGeometries[this.geometry];
        }
        return undefined;
    }
}
ThreeObject3dMaterialGeometry.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeObject3dMaterialGeometry, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ThreeObject3dMaterialGeometry.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeObject3dMaterialGeometry, inputs: { geometry: "geometry", material: "material", morphTargetInfluences: "morphTargetInfluences", morphTargetDictionary: "morphTargetDictionary" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeObject3dMaterialGeometry, decorators: [{
            type: Directive
        }], propDecorators: { geometry: [{
                type: Input
            }], material: [{
                type: Input
            }], morphTargetInfluences: [{
                type: Input
            }], morphTargetDictionary: [{
                type: Input
            }] } });

class ThreeMaterial {
    constructor(ngZone, instancesStore, canvasStore) {
        this.ngZone = ngZone;
        this.instancesStore = instancesStore;
        this.canvasStore = canvasStore;
    }
    set parameters(v) {
        this._parameters = v;
        if (v && this.material) {
            this.ngZone.runOutsideAngular(() => {
                this.convertColorToLinear(v);
                this.material.setValues(v);
                this.material.needsUpdate = true;
            });
        }
    }
    get parameters() {
        return this._parameters;
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (this.parameters) {
                this.convertColorToLinear(this.parameters);
            }
            this._material = new this.materialType(this.parameters);
            this.instancesStore.saveMaterial({
                id: this.ngtId,
                material: this._material,
            });
        });
    }
    get material() {
        return this._material;
    }
    convertColorToLinear(parameters) {
        if ('color' in parameters) {
            const colorParams = parameters['color'];
            parameters['color'] = Array.isArray(colorParams)
                ? new Color(...colorParams)
                : new Color(colorParams);
            if (!this.canvasStore.getImperativeState().isLinear) {
                parameters['color'].convertSRGBToLinear();
            }
        }
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.material) {
                this.instancesStore.removeMaterial(this.ngtId || this.material.uuid);
                this.material.dispose();
            }
        });
    }
}
ThreeMaterial.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMaterial, deps: [{ token: i0.NgZone }, { token: InstancesStore, skipSelf: true }, { token: CanvasStore, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });
ThreeMaterial.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeMaterial, inputs: { ngtId: "ngtId", parameters: "parameters" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMaterial, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: InstancesStore, decorators: [{
                    type: SkipSelf
                }] }, { type: CanvasStore, decorators: [{
                    type: SkipSelf
                }] }]; }, propDecorators: { ngtId: [{
                type: Input
            }], parameters: [{
                type: Input
            }] } });

class ThreeTexture {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this._extraArgs = [];
    }
    set extraArgs(v) {
        this._extraArgs = v;
        this.ngZone.runOutsideAngular(() => {
            this._texture = new this.textureType(...this._extraArgs);
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!this.texture) {
                this._texture = new this.textureType(...this._extraArgs);
            }
        });
    }
    get texture() {
        return this._texture;
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.texture) {
                this.texture.dispose();
            }
        });
    }
}
ThreeTexture.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeTexture, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
ThreeTexture.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeTexture, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeTexture, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });

class ThreeLight extends ThreeObject3d {
    constructor() {
        super(...arguments);
        this._extraArgs = [];
    }
    set extraArgs(v) {
        this._extraArgs = v;
        this.ngZone.runOutsideAngular(() => {
            this.init();
        });
    }
    ngOnInit() {
        if (!this.object3d) {
            this.init();
        }
    }
    initObject() {
        if (this.intensity) {
            this._extraArgs[1] = this.intensity;
        }
        this._light = new this.lightType(...this._extraArgs);
    }
    get object3d() {
        return this._light;
    }
}
ThreeLight.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeLight, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ThreeLight.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeLight, inputs: { intensity: "intensity" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeLight, decorators: [{
            type: Directive
        }], propDecorators: { intensity: [{
                type: Input
            }] } });

class ThreeHelper extends ThreeObject3d {
    constructor() {
        super(...arguments);
        this._extraArgs = [];
        this.inputChangeHandler = () => {
            if (!this.object3d) {
                this.init();
            }
        };
    }
    set extraArgs(v) {
        this._extraArgs = v;
        this.ngZone.runOutsideAngular(() => {
            this.init();
        });
    }
    ngOnChanges() {
        super.ngOnChanges();
        this.inputChangeHandler();
    }
    ngOnInit() {
        this.inputChangeHandler();
    }
    initObject() {
        try {
            this._helper = new this.helperType(...this._extraArgs);
        }
        catch (e) {
            console.log('Failed to initialize Helper');
        }
    }
    get object3d() {
        return this._helper;
    }
}
ThreeHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeHelper, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ThreeHelper.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeHelper, usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeHelper, decorators: [{
            type: Directive
        }] });

class ThreeBufferGeometry {
    constructor(instancesStore, ngZone) {
        this.instancesStore = instancesStore;
        this.ngZone = ngZone;
        this._extraArgs = [];
    }
    set extraArgs(v) {
        this._extraArgs = v;
        this.ngZone.runOutsideAngular(() => {
            this.init();
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!this.bufferGeometry) {
                this.init();
            }
        });
    }
    init() {
        this._bufferGeometry = new this.geometryType(...this._extraArgs);
        this.instancesStore.saveBufferGeometry({
            id: this.ngtId,
            bufferGeometry: this._bufferGeometry,
        });
    }
    get bufferGeometry() {
        return this._bufferGeometry;
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.bufferGeometry) {
                this.instancesStore.removeBufferGeometry(this.ngtId || this.bufferGeometry.uuid);
                this.bufferGeometry.dispose();
            }
        });
    }
}
ThreeBufferGeometry.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeBufferGeometry, deps: [{ token: InstancesStore, skipSelf: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
ThreeBufferGeometry.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeBufferGeometry, inputs: { ngtId: "ngtId" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeBufferGeometry, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: InstancesStore, decorators: [{
                    type: SkipSelf
                }] }, { type: i0.NgZone }]; }, propDecorators: { ngtId: [{
                type: Input
            }] } });

class ThreeCurve {
    constructor(ngZone, geometryDirective) {
        this.ngZone = ngZone;
        this.geometryDirective = geometryDirective;
        this._extraArgs = [];
    }
    set extraArgs(v) {
        this._extraArgs = v;
        this.ngZone.runOutsideAngular(() => {
            this.init();
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!this.curve) {
                this.init();
            }
        });
    }
    init() {
        this._curve = new this.curveType(...this._extraArgs);
        if (this.curve && this.geometryDirective) {
            const points = this.curve.getPoints(this.divisions);
            this.geometryDirective.bufferGeometry.setFromPoints(points);
        }
    }
    get curve() {
        return this._curve;
    }
}
ThreeCurve.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeCurve, deps: [{ token: i0.NgZone }, { token: ThreeBufferGeometry, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
ThreeCurve.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeCurve, inputs: { divisions: "divisions" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeCurve, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: ThreeBufferGeometry, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { divisions: [{
                type: Input
            }] } });

class ThreeAttribute {
    constructor(ngZone, geometryDirective) {
        this.ngZone = ngZone;
        this.geometryDirective = geometryDirective;
        this._extraArgs = [];
    }
    set extraArgs(v) {
        this._extraArgs = v;
        this.ngZone.runOutsideAngular(() => {
            this.init();
        });
    }
    ngOnChanges() {
        this.ngZone.runOutsideAngular(() => {
            if (this.attribute) {
                this.attribute.needsUpdate = true;
            }
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!this.attribute) {
                this.init();
            }
        });
    }
    init() {
        if (this.geometryDirective && this.attach) {
            this._attribute = new this.attributeType(...this._extraArgs);
            if (this.attribute) {
                this.geometryDirective.bufferGeometry.setAttribute(this.attach, this.attribute);
            }
        }
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.geometryDirective && this.attach) {
                this.geometryDirective.bufferGeometry.deleteAttribute(this.attach);
            }
        });
    }
    get attribute() {
        return this._attribute;
    }
}
ThreeAttribute.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeAttribute, deps: [{ token: i0.NgZone }, { token: ThreeBufferGeometry, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
ThreeAttribute.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeAttribute, inputs: { attach: "attach" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeAttribute, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: ThreeBufferGeometry, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { attach: [{
                type: Input
            }] } });

class ThreeLine extends ThreeObject3dMaterialGeometry {
    set materialDirectives(v) {
        if (this.material == null && v) {
            this.material =
                v.length === 1
                    ? v.first.material
                    : v.toArray().map((dir) => dir.material);
        }
    }
    set bufferGeometryDirective(v) {
        if (this.geometry == null) {
            this.geometry = v.bufferGeometry;
        }
    }
    get objectType() {
        return this.lineType;
    }
}
ThreeLine.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeLine, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ThreeLine.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeLine, queries: [{ propertyName: "bufferGeometryDirective", first: true, predicate: ThreeBufferGeometry, descendants: true }, { propertyName: "materialDirectives", predicate: ThreeMaterial }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeLine, decorators: [{
            type: Directive
        }], propDecorators: { materialDirectives: [{
                type: ContentChildren,
                args: [ThreeMaterial]
            }], bufferGeometryDirective: [{
                type: ContentChild,
                args: [ThreeBufferGeometry]
            }] } });

class ThreeMesh extends ThreeObject3dMaterialGeometry {
    set materialDirectives(v) {
        if (this.material == null && v) {
            this.material =
                v.length === 1
                    ? v.first.material
                    : v.toArray().map((dir) => dir.material);
        }
    }
    set bufferGeometryDirective(v) {
        if (this.geometry == null && v) {
            this.geometry = v.bufferGeometry;
        }
    }
    get objectType() {
        return this.meshType;
    }
}
ThreeMesh.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMesh, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ThreeMesh.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeMesh, queries: [{ propertyName: "bufferGeometryDirective", first: true, predicate: ThreeBufferGeometry, descendants: true }, { propertyName: "materialDirectives", predicate: ThreeMaterial }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMesh, decorators: [{
            type: Directive
        }], propDecorators: { materialDirectives: [{
                type: ContentChildren,
                args: [ThreeMaterial]
            }], bufferGeometryDirective: [{
                type: ContentChild,
                args: [ThreeBufferGeometry]
            }] } });

class ThreeSprite extends ThreeObject3d {
    ngAfterContentInit() {
        this.init();
    }
    initObject() {
        if (this.material) {
            this._sprite = new this.spriteType(this.material);
            return;
        }
        if (this.materialDirective) {
            if (this.materialDirective.material instanceof SpriteMaterial) {
                this._sprite = new this.spriteType(this.materialDirective.material);
                return;
            }
            console.warn(`Sprite can only be instantiated with SpriteMaterial`);
        }
    }
    get object3d() {
        return this._sprite;
    }
}
ThreeSprite.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeSprite, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ThreeSprite.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeSprite, inputs: { material: "material" }, queries: [{ propertyName: "materialDirective", first: true, predicate: ThreeMaterial, descendants: true }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeSprite, decorators: [{
            type: Directive
        }], propDecorators: { material: [{
                type: Input
            }], materialDirective: [{
                type: ContentChild,
                args: [ThreeMaterial]
            }] } });

class ThreeCamera extends ThreeObject3d {
    constructor() {
        super(...arguments);
        this._extraArgs = [];
    }
    set extraArgs(v) {
        this._extraArgs = v;
        this.ngZone.runOutsideAngular(() => {
            this.init();
        });
    }
    ngOnInit() {
        if (!this.object3d) {
            this.init();
        }
    }
    initObject() {
        this._camera = new this.cameraType(...this._extraArgs);
    }
    get object3d() {
        return this._camera;
    }
}
ThreeCamera.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeCamera, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ThreeCamera.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ThreeCamera, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeCamera, decorators: [{
            type: Directive
        }] });

class PrimitiveDirective extends AnimationLoopParticipant {
    constructor(animationStore, ngZone, object3dController, canvasStore, parentObjectDirective) {
        super(animationStore, ngZone);
        this.animationStore = animationStore;
        this.ngZone = ngZone;
        this.object3dController = object3dController;
        this.canvasStore = canvasStore;
        this.parentObjectDirective = parentObjectDirective;
        this.ready = new EventEmitter();
    }
    get object() {
        return this._object;
    }
    set object(value) {
        if (value == null) {
            console.error('[object] is required');
        }
        this._object = value;
        if (value) {
            this.ready.emit(value);
            this.participate(value);
        }
    }
    get object3d() {
        return this._object;
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.appendToParent();
        });
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.ngZone.runOutsideAngular(() => {
            if (this.object3d) {
                this.remove();
            }
        });
    }
    appendToParent() {
        if (this.object3d && this.object3d instanceof Object3D) {
            if (this.object3dController.appendTo) {
                this.object3dController.appendTo.add(this.object3d);
                return;
            }
            const { scene } = this.canvasStore.getImperativeState();
            if (this.object3dController.appendMode === 'root') {
                if (scene) {
                    scene.add(this.object3d);
                }
                return;
            }
            if (this.object3dController.appendMode === 'immediate') {
                if (this.parentObjectDirective) {
                    this.parentObjectDirective.object3d.add(this.object3d);
                }
                else {
                    if (scene) {
                        scene.add(this.object3d);
                    }
                }
            }
        }
    }
    remove() {
        if (this.object3d instanceof Object3D) {
            if (this.object3dController.appendTo) {
                this.object3dController.appendTo.remove(this.object3d);
            }
            else if (this.parentObjectDirective &&
                this.object3dController.appendMode === 'immediate') {
                this.parentObjectDirective.object3d.remove(this.object3d);
            }
            else {
                const { scene } = this.canvasStore.getImperativeState();
                if (scene) {
                    scene.remove(this.object3d);
                }
            }
            this.object3d.clear();
        }
    }
}
PrimitiveDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: PrimitiveDirective, deps: [{ token: AnimationStore }, { token: i0.NgZone }, { token: OBJECT_3D_WATCHED_CONTROLLER }, { token: CanvasStore }, { token: ThreeObject3d, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });
PrimitiveDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: PrimitiveDirective, selector: "ngt-primitive", inputs: { object: "object" }, outputs: { ready: "ready" }, providers: [
        {
            provide: ThreeObject3d,
            useExisting: PrimitiveDirective,
        },
        OBJECT_3D_CONTROLLER_PROVIDER,
    ], exportAs: ["ngtPrimitive"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: PrimitiveDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ngt-primitive',
                    exportAs: 'ngtPrimitive',
                    providers: [
                        {
                            provide: ThreeObject3d,
                            useExisting: PrimitiveDirective,
                        },
                        OBJECT_3D_CONTROLLER_PROVIDER,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: AnimationStore }, { type: i0.NgZone }, { type: Object3dControllerDirective, decorators: [{
                    type: Inject,
                    args: [OBJECT_3D_WATCHED_CONTROLLER]
                }] }, { type: CanvasStore }, { type: ThreeObject3d, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }]; }, propDecorators: { ready: [{
                type: Output
            }], object: [{
                type: Input
            }] } });

class ThreePrimitiveModule {
}
ThreePrimitiveModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreePrimitiveModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ThreePrimitiveModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreePrimitiveModule, declarations: [PrimitiveDirective], exports: [PrimitiveDirective] });
ThreePrimitiveModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreePrimitiveModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreePrimitiveModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [PrimitiveDirective],
                    exports: [PrimitiveDirective],
                }]
        }] });

class MathPipe {
    transform(value, keyOfMath) {
        const params = Array.isArray(value) ? value : [value];
        return Math[keyOfMath](...params);
    }
}
MathPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: MathPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
MathPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: MathPipe, name: "math" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: MathPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'math',
                    pure: true,
                }]
        }] });

class ThreeMathPipeModule {
}
ThreeMathPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMathPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ThreeMathPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMathPipeModule, declarations: [MathPipe], exports: [MathPipe] });
ThreeMathPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMathPipeModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMathPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MathPipe],
                    exports: [MathPipe],
                }]
        }] });

class MathConstantPipe {
    transform(value, keyOfMathConst) {
        if (keyOfMathConst === 'random') {
            return Math.random();
        }
        return value * Math[keyOfMathConst];
    }
}
MathConstantPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: MathConstantPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
MathConstantPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: MathConstantPipe, name: "mathConst" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: MathConstantPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'mathConst',
                    pure: true,
                }]
        }] });

class ThreeMathConstantPipeModule {
}
ThreeMathConstantPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMathConstantPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ThreeMathConstantPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMathConstantPipeModule, declarations: [MathConstantPipe], exports: [MathConstantPipe] });
ThreeMathConstantPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMathConstantPipeModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeMathConstantPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MathConstantPipe],
                    exports: [MathConstantPipe],
                }]
        }] });

class ColorPipe {
    /**
     * ConstructorParameters<typeof THREE.Color> has a limitation on THREE.Color constructor overloads
     */
    transform(args) {
        return new THREE.Color(...args);
    }
}
ColorPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ColorPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
ColorPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ColorPipe, name: "color" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ColorPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'color',
                    pure: true,
                }]
        }] });

class ThreeColorPipeModule {
}
ThreeColorPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeColorPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ThreeColorPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeColorPipeModule, declarations: [ColorPipe], exports: [ColorPipe] });
ThreeColorPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeColorPipeModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeColorPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ColorPipe],
                    exports: [ColorPipe],
                }]
        }] });

class FogPipe {
    transform(args) {
        return new THREE.Fog(...args);
    }
}
FogPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: FogPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
FogPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: FogPipe, name: "fog" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: FogPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'fog',
                    pure: true,
                }]
        }] });

class ThreeFogPipeModule {
}
ThreeFogPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeFogPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ThreeFogPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeFogPipeModule, declarations: [FogPipe], exports: [FogPipe] });
ThreeFogPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeFogPipeModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeFogPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [FogPipe],
                    exports: [FogPipe],
                }]
        }] });

const MAX_VALUE = 0x10000;
class RepeatDirective {
    constructor(viewContainer, templateRef) {
        this.viewContainer = viewContainer;
        this.templateRef = templateRef;
    }
    set repeatOf(count) {
        const safeCount = Math.floor(Math.max(0, Math.min(count, MAX_VALUE)));
        const { length } = this.viewContainer;
        if (safeCount < length) {
            this.removeContainers(length - safeCount);
        }
        else {
            this.addContainers(length, safeCount);
        }
    }
    addContainers(length, count) {
        for (let index = length; index < count; index++) {
            this.viewContainer.createEmbeddedView(this.templateRef, {
                $implicit: index,
                isFirst: index === length,
                isLast: index === count - 1,
                isOdd: !(index % 2),
                isEven: !!(index % 2),
            });
        }
    }
    removeContainers(amount) {
        for (let index = 0; index < amount; index++) {
            this.viewContainer.remove();
        }
    }
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
}
RepeatDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: RepeatDirective, deps: [{ token: ViewContainerRef }, { token: TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
RepeatDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: RepeatDirective, selector: "[repeat][repeatOf]", inputs: { repeatOf: "repeatOf" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: RepeatDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[repeat][repeatOf]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef, decorators: [{
                    type: Inject,
                    args: [ViewContainerRef]
                }] }, { type: i0.TemplateRef, decorators: [{
                    type: Inject,
                    args: [TemplateRef]
                }] }]; }, propDecorators: { repeatOf: [{
                type: Input
            }] } });

class ThreeRepeatModule {
}
ThreeRepeatModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeRepeatModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ThreeRepeatModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeRepeatModule, declarations: [RepeatDirective], exports: [RepeatDirective] });
ThreeRepeatModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeRepeatModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0, type: ThreeRepeatModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RepeatDirective],
                    exports: [RepeatDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AnimationLoopParticipant, AnimationStore, CanvasComponent, CanvasStore, ColorPipe, Controller, DestroyedService, EventsStore, FogPipe, InstancesStore, LoaderService, LoopService, MathConstantPipe, MathPipe, OBJECT_3D_CONTROLLER_PROVIDER, OBJECT_3D_WATCHED_CONTROLLER, Object3dControllerDirective, PrimitiveDirective, RepeatDirective, ThreeAttribute, ThreeBufferGeometry, ThreeCamera, ThreeColorPipeModule, ThreeCoreModule, ThreeCurve, ThreeFogPipeModule, ThreeHelper, ThreeLight, ThreeLine, ThreeMaterial, ThreeMathConstantPipeModule, ThreeMathPipeModule, ThreeMesh, ThreeObject3d, ThreeObject3dMaterialGeometry, ThreePrimitiveModule, ThreeRepeatModule, ThreeSprite, ThreeTexture, applyProps, isOrthographicCamera, object3dWatchedControllerFactory };
//# sourceMappingURL=angular-three-core.js.map
